# 📒12장_ 함수
### 📑목차
- [함수](#함수)
- [함수 정의](#함수-정의)
- [함수 호출](#함수-호출)

### ⚡Quick Summary
- 함수 정의 방식 4가지
    - *함수 선언문*
        - *표현식이 아닌 문*
        - 함수 이름 생략 불가능 (항상 기명 함수)
        - 런타임 이전에 함수 객체가 먼저 생성되고, 자바스크립트 엔진이 **함수 이름과 동일한 이름의 식별자를 암묵적으로 생성**해 생성된 함수 객체를 할당하는 ***함수 호이스팅(function hoisting)*** 발생
    - *함수 표현식*
        - *표현식인 문*
        - 함수 이름 생략 가능 (기명/익명 함수)
        - 변수에 함수를 값으로 할당해 사용하므로 함수 호이스팅이 아니라 ***변수 호이스팅***이 발생
    - *`Function` 생성자 함수*
        - 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하기 때문에 권장 X
    - *화살표 함수*
        - *표현식인 문*
        - **항상 익명 함수**로 정의
        - 화살표(fat arrow) `=>`를 사용해 좀 더 간략한 방법으로 함수 선언
- 함수 호출
    - 매개변수의 스코프(유효범위)는 함수 내부
    - 매개변수(parameter)를 통해 인수(argument)를 전달
        - 인수의 개수가 부족해 인수가 할당되지 않은 매개변수의 값은 `undefined`
        - 인수의 개수가 더 많은 경우 초과된 인수는 암묵적으로 `arguments` 객체의 프로퍼티로 보관됨
    - 매개변수 개수는 적을 수록 좋으며 3개 이상의 매개변수가 필요한 경우, **하나의 매개변수를 선언하고 객체를 인수로 전달**하는 것이 유리 (객체 프로퍼티를 사용하여 매개변수 순서를 신경쓰지 않아도 되기 때문)

## 📌함수
> 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 함수의 구성 요소
    - *매개변수(parameter)*: 입력을 전달받는 변수
    - *인수(argument)*: 입력
    - *반환값(return value)*: 출력

```jsx
/*
*  함수 정의(function definition)
*/
function add(x, y) {    // ← 매개변수 x, y
    return x + y;   // ← 반환값 x + y
}

/*
*  함수 호출(function call/invoke)
*/
add(2, 5);  // ← 인수 2, 5
```
- 함수를 통해 **중복을 제거**하고 **코드 재사용** 가능
- 유지보수와 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높임
- 일반 객체는 호출할 수 없지만 함수는 호출 가능
<details>
<summary>함수 리터럴 ⇒ 함수는 <i>객체 타입의 값</i></summary>
<ul>
    <li>
        함수 리터럴 구성 요소
        <ul>
            <li>
                함수 이름
                <ul>
                    <li><i>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자</i></li>
                    <li>함수 이름 생략 가능</li>
                </ul>
            </li>
            <li>
                매개변수 목록
                <ul>
                    <li>각 매개변수에 지정한 인수가 순서대로 할당됨</li>
                </ul>
            </li>
            <li>
                함수 몸체
                <ul>
                    <li>호출에 의해 실행됨</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
</details>

## 📌함수 정의
> ✔️변수는 *선언(declaration)*, 함수는 *정의(definition)* 라고 표현 - ECMAScript
- 함수 정의 방식 4가지: 함수 선언문, 함수 표현식, `Function` 생성자 함수, 화살표 함수
### 함수 선언문
- 함수 선언문이 평가되면 **식별자가 암묵적으로 생성**되고 함수 객체가 할당됨!
- 함수 리터럴과 형태 동일 (단, 함수 리터럴은 함수 이름을 생략할 수 있지만, 함수 선언문은 생략할 수 없음)
- ✔️표현식이 아닌 문
    - 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있음
    - 즉, 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있음
    ```jsx
    function add(x, y) {
        return x + y;
    }

    console.log(add(1, 2)); // 3
    ```
- 함수 리터럴: *"함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다"*<br>⇒ 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다<br>⇒ ***함수를 가리키는 식별자가 없다!***
- ⭐자바스크립트 엔진은 생성된 함수를 호출하기 위해 ***함수 이름과 동일한 이름의 식별자를 암묵적으로 생성***하고, 거기에 함수 객체를 할당한다!!
- 따라서 사실 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출하는 것 (함수 이름과 식별자 이름이 동일해서 마치 함수 이름으로 호출하는 것처럼 보이는 것)
- 의사 코드
    ```jsx
    var add = function add(x, y) {
        return x + y;
    };
    
    console.log(add(1, 2)); // 3
    ```
    - 결론적으로 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있음
- ✔️런타임 이전에 함수 객체가 먼저 생성되고, 자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성해 생성된 함수 객체를 할당하는 **함수 호이스팅(function hoisting)** 발생
    ```jsx
    // 함수 참조
    console.dir(add); // ƒ add(x, y)

    // 함수 호출
    console.log(add(2, 5)); // 7

    // 함수 선언문
    function add(x, y) {
        return x + y;
    }
    ```
### 함수 표현식
  - 함수 선언문을 변수에 할당
  - 자바스크립트의 함수는 값의 성질을 갖는 객체인 *일급 객체*
  ```jsx
  var add = function (x, y) {
      return x + y;
  };
  ```
  - 보통 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적
  - ✔️표현식인 문
  - ✔️변수에 함수를 값으로 할당해 사용하므로 **함수 호이스팅이 아니라 변수 호이스팅이 발생**
    ```jsx
    // 함수 참조
    console.dir(sub); // undefined

    // 함수 호출
    console.log(sub(2, 5)); // TypeError: sub is not a function

    // 함수 표현식
    var sub = function (x, y) {
        return x - y;
    };
    ```
### Function 생성자 함수
- 자바스크립트가 기본 제공하는 built-in 함수
- `new` 연산자 없이 호출해도 무방
```jsx
var add = new Function('x', 'y', 'return x + y');
```
- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지 않음
    - 클로저(closure)를 생성하지 않는 등 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작
    ```jsx
    var add1 = (function () {
        var a = 10;
        return function (x, y) {
            return x + y + a;
        };
    }());

    console.log(add1(1, 2)); // 13

    var add2 = (function () {
        var a = 10;
        return new Function('x', 'y', 'return x + y + a;');
    }());

    console.log(add2(1, 2)); // ReferenceError: a is not defined
    ```
### 화살표 함수(ES6)
- `function` 키워드 대신 화살표(fat arrow) `=>`를 사용해 좀 더 간략한 방법으로 함수 선언
- 항상 *익명 함수*로 정의
```jsx
var add = (x, y) => x + y;
```
- 생성자 함수로 사용 불가능
- 기존 함수와 this 바인딩 방식이 다름
- prototype 프로퍼티가 없음
- `arguments` 객체 생성 X

## 📌함수 호출
- 매개변수(parameter)를 통해 인수(argument)를 전달
- 매개변수는 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 `undefined`로 초기화된 이후 인수가 순서대로 할당됨
- 매개변수의 스코프(유효범위)는 함수 내부
- 인수의 개수가 부족해 인수가 할당되지 않은 매개변수의 값은 `undefined`
    ```jsx
    function add(x, y) {
        return x + y;
    }

    console.log(add(2)); // 2 + undefined = NaN
    ```
- 인수의 개수가 더 많은 경우 초과된 인수는 암묵적으로 `arguments` 객체의 프로퍼티로 보관됨
    ```jsx
    function add(x, y) {
        console.log(arguments);
        // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]

        return x + y;
    }

    add(2, 5, 10);
    ```
- 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 하기 때문에 이상적인 매개변수 개수는 0개이며 적을 수록 좋음
- 이상적인 함수는 한 가지 일만 해야하며 가급적 작게 만들어야 함
- 매개변수 개수는 최대 3개 이상을 넘지 않는 것을 권장
- ✔️만약 그 이상의 매개변수가 필요한 경우, **하나의 매개변수를 선언하고 객체를 인수로 전달**하는 것이 유리 → 객체를 사용하면 프로퍼티 키를 사용하므로 매개변수 순서를 신경쓰지 않아도 됨!
    - 단, 전달받은 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 *부수 효과*(side effect)가 발생함에 주의 (참조에 의한 전달)
    ```jsx
    // 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
    function changeVal(primitive, obj) {
        primitive += 100;
        obj.name = 'Kim';
    }

    // 외부 상태
    var num = 100;
    var person = { name: 'Lee' };

    console.log(num); // 100
    console.log(person); // {name: "Lee"}

    // 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
    changeVal(num, person);

    // 원시 값은 원본이 훼손되지 않는다.
    console.log(num); // 100

    // 객체는 원본이 훼손된다.
    console.log(person); // {name: "Kim"}
    ```
    - *순수 함수(pure function)*
        > 부수 효과가 없는 함수 ⇒ 함수형 프로그래밍
        - 동일한 인수가 전달되면 언제나 동일한 값을 반환
        - 매개변수가 없으면 상수와 같기 때문에 보통 매개변수는 1개 이상
    - *비순수 함수(impure function)*
        > 부수 효과가 있는 함수
- 함수의 반환문을 생략하거나 `return` 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면(`return;`) `undefined` 반환