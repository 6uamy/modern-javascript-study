# 📒23장_ 실행 컨텍스트
### 📑목차
- [소스코드의 타입](#소스코드의-타입)
- [소스코드의 평가와 실행](#소스코드의-평가와-실행)
- [실행 컨텍스트의 역할](#실행-컨텍스트의-역할)
- [실행 컨텍스트 스택](#실행-컨텍스트-스택)
- [렉시컬 환경](#렉시컬-환경)
- [실행 컨텍스트의 생성과 식별자 검색 과정](#실행-컨텍스트의-생성과-식별자-검색-과정)
- [실행 컨텍스트와 블록 레벨 스코프](#실행-컨텍스트와-블록-레벨-스코프)

### ⚡Quick Summary
- 실행 컨텍스트를 생성하는 4가지 타입의 ECMAScript 소스 코드 타입
    1. *전역 코드(global code)*
    2. *함수 코드(function code)*
    3. *eval 코드(eval code)*
    4. *모듈 코드(module code)*
- 자바스크립트 엔진은 소스코드를 **평가**와 **실행** 두 과정으로 나누어 처리
    1. *소스코드의 평가*
        - 실행 컨텍스트 생성
        - 렉시컬 환경 생성
            - 선언문만 먼저 실행해서 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
    2. *소스코드의 실행*
        - 선언문을 제외한 소스코드가 순차적으로 실행 (런타임 시작)
        - 소스코드의 실행 결과를 다시 실행 컨텍스트가 관리하는 스코프에 반영
- ***실행 컨텍스트***: *LexicalEnvironment* & *VariableEnvironment*
    > 스코프, 식별자, 코드 실행 순서 등을 관리하는 영역
    - **실행 컨텍스트 스택**
        > 코드 실행 순서 관리
    - **렉시컬 환경**: *환경 레코드* & *외부 렉시컬 환경에 대한 참조*
        > 식별자와 스코프 관리, 렉시컬 스코프의 실체

## 📌소스코드의 타입
- 4가지 타입의 ECMAScript code는 실행 컨텍스트(execution context)를 생성
    - *전역 코드*
        > 전역에 존재하는 소스코드(전역에 정의된 함수, 클래스 등의 내부 코드 미포함)
        1. 전역 스코프 (최상위 스코프) 생성
        2. 전역 객체와 연결
        3. `var` 키워드로 선언된 전역 변수 + 선언된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩
    - *함수 코드*
        > 함수 내부에 존재하는 소스코드(함수 내부에 중첩된 함수, 클래스 등의 내부 코드 미포함)
        1. 지역 스코프 생성
        2. 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결
        3. 지역 변수, 매개변수, `arguments` 객체 관리
    - *eval 코드*
        > 빌트인 전역 함수인 `eval` 함수에 인수로 전달되어 실행되는 소스코드
        - strict mode 에서 독자적인 스코프 생성 
    - *모듈 코드*
        > 모듈 내부에 존재하는 소스코드(모듈 내부의 함수, 클래스 등의 내부 코드 미포함)
        - 독립적인 모듈 스코프 생성

## 📌소스코드의 평가와 실행
- 자바스크립트 엔진은 소스코드를 "**소스코드의 평가**"와 "**소스코드의 실행**", 2개의 과정으로 나누어 처리
    1. *소스코드의 평가*
        - 실행 컨텍스트 생성
        - 선언문(변수, 함수 등)만 먼저 실행
        - 생성된 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
    2. *소스코드의 실행*
        - 선언문을 제외한 소스코드가 순차적으로 실행 (런타임 시작)
        - 소스코드 실행에 필요한 정보(변수나 함수의 참조)는 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득
        - 소스코드의 실행 결과(변수 값의 변경 등)는 다시 실행 컨텍스트가 관리하는 스코프에 등록

![image](https://github.com/namu56/modern-javascript-study/assets/71831926/8698ca43-d9c9-4252-9635-5cee090811b1)
## 📌실행 컨텍스트의 역할
- 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요!
- ⭐***실행 컨텍스트***
    > 스코프, 식별자, 코드 실행 순서 등을 관리하는 영역
    - 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 실행 순서 관리를 구현한 내부 메커니즘
    - 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됨
    - ✔️식별자와 스코프는 **실행 컨텍스트의 렉시컬 환경**으로 관리
    - ✔️코드 실행 순서는 **실행 컨텍스트 스택**으로 관리

## 📌실행 컨텍스트 스택
> 코드의 실행 순서 관리
```jsx
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```
![image](https://github.com/namu56/modern-javascript-study/assets/71831926/a516f4dd-9a61-43a4-bef6-60b277f39a43)
(실행 컨텍스트 = Execution Context = EC로 표기))
1. 전역 코드 평가 & 실행
    - 전역 코드를 평가하여 EC 생성(push)
    - 전역 EC에 전역 변수 x와 전역 함수 foo 등록
    - 코드가 실행되면서 전역 변수 x에 값이 할당되고 전역 함수 foo가 호출됨
2. foo 함수 코드 평가 & 실행
    - foo 호출 시 **전역 코드 실행 일시 중지**, 코드의 제어권(control)이 **foo 함수 내부**로 이동
    - foo 함수를 평가하여 EC 생성(push)
    - foo 함수 EC에 지역 변수 y와 중첩 함수 bar 등록
    - foo 함수 코드가 실행되면서 지역 변수 y에 값이 할당되고 중첩 함수 bar가 호출됨
3. bar 함수 코드 평가 & 실행
    - 중첩 함수 bar 호출 시 **foo 함수 코드 실행 일시 중지**, 코드의 제어권이 **bar 함수 내부로 이동**
    - bar 함수를 평가하여 EC 생성(push)
    - bar 함수 EC에 지역 변수 z 등록
    - bar 함수 코드가 실행되면서 지역 변수 z에 값이 할당되고 `console.log` 메서드 호출
    - bar 함수 종료
4. foo 함수 코드로 복귀
    - bar 함수 종료 시 코드의 제어권이 다시 **foo 함수로 이동**
    - bar 함수 EC를 EC 스택에서 제거(pop)
    - foo 함수 종료
5. 전역 코드로 복귀
    - foo 함수 종료 시 코도의 제어권이 다시 **전역 코드로 이동**
    - foo 함수 EC를 EC 스택에서 제거(pop)
    - 전역 EC도 종료되면서 EC 스택에서 제거(pop)

## 📌렉시컬 환경
> 스코프와 식별자 관리
- 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트
- 스코프를 구분하여 식별자를 등록(key-value 객체 형태)하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체
- **실행 컨텍스트**를 구성하는 컴포넌트
    1. *LexicalEnvironment*
    2. *VariableEnvironment*
    - 생성 초기에 두 컴포넌트 모두 하나의 동일한 렉시컬 환경 참조
    ![실행 컨텍스트 구성](https://github.com/namu56/modern-javascript-study/assets/71831926/8ab968ef-3588-4208-a12c-919ebd739f48)
    - 이후 몇 가지 상황을 만나면 VariableEvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성하고 각 컴포넌트는 내용이 달라지는 경우도 존재
    - 💡책에서는 이 둘을 그냥 LexicalEnvironment로 통일해서 설명함
- ⭐**렉시컬 환경**을 구성하는 컴포넌트
    1. *환경 레코드(Environment Record)*
        > 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소
    2. *외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)*
        > 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 가리킴

## 📌실행 컨텍스트의 생성과 식별자 검색 과정
```jsx
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```
1. [전역 객체 생성](#1-전역-객체-생성)
2. [전역 코드 평가](#2-전역-코드-평가)
3. [전역 코드 실행](#3-전역-코드-실행)
4. [foo 함수 코드 평가](#4-foo-함수-코드-평가)
5. [foo 함수 코드 실행](#5-foo-함수-코드-실행)
6. [bar 함수 코드 평가](#6-bar-함수-코드-평가)
7. [bar 함수 코드 실행](#7-bar-함수-코드-실행)
8. [bar 함수 코드 실행 종료](#8-bar-함수-코드-실행-종료)
9. [foo 함수 코드 실행 종료](#9-foo-함수-코드-실행-종료)
10. [전역 코드 실행 종료](#10-전역-코드-실행-종료)
---
### 1. 전역 객체 생성
- `window`/`global` 객체 생성
- `BindingObject`라는 전역 객체 생성
### 2. 전역 코드 평가
![전역 실행 컨텍스트와 렉시컬 환경](https://github.com/namu56/modern-javascript-study/assets/71831926/da2dc99a-92d0-45df-a88c-47c1afa4979d)
1. ***전역 실행 컨텍스트 생성***
    - 실행 컨텍스트 스택에 push
2. ***전역 렉시컬 환경 생성***
    - 전역 실행 컨텍스트에 바인딩
    1. ***전역 환경 레코드 생성***
        - ⭐**전역 환경 레코드**는 기존 `var` 키워드로 선언한 전역 변수와 ES6의 `let`, `const` 키워드로 선언한 전역 변수를 구분하여 관리하기 위해 *객체 환경 레코드*(`var`)와 *선언적 환경 레코드*(`let`, `const`)로 구성됨
        1. ***객체 환경 레코드 생성***
            - `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 객체 환경 레코드에 연결된 `BindingObject`를 통해 전역 객체의 프로퍼티와 메서드가 됨
            - `var` 변수는 전역 코드 평가 시점에 `BindingObject`를 통해 전역 객체에 변수 식별자를 키로 등록한 다음(선언 단계), 암묵적으로 `undefined`를 바인딩(초기화 단계)
            - 함수 선언문으로 정의한 함수가 평가되면 함수 이름과 동일한 식별자가 `BindingObject`를 통해 전역 객체에 키로 등록하고, 생성된 함수 객체를 즉시 할당
        2. ***선언적 환경 레코드 생성***
            - `let`과 `const` 키워드로 선언된 변수 식별자를 키로 등록(선언 단계)
            - 초기화 단계가 진행되지 않았기 때문에 <uninitialized>라고 표현됨(실제 이 값이 바인딩된 것은 아님)
    2. ***this 바인딩***
        - 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 this가 바인딩됨
    3. ***외부 렉시컬 환경에 대한 참조 결정***
        - 전역 코드를 포함하는 소스코드는 없으므로 `null`이 할당됨
        - 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미

### 3. 전역 코드 실행
- 전역 코드가 순차적으로 실행되며 변수 할당문이 실행되어 전역 변수 x, y에 값이 할당됨
- foo 함수가 호출됨

### 4. foo 함수 코드 평가
![foo 함수 실행 컨텍스트와 렉시컬 환경](https://github.com/namu56/modern-javascript-study/assets/71831926/31c06096-074c-4c19-ac5c-cd457d5a998f)
- foo 함수 호출 시 전역 코드의 실행을 일시 중지, foo 함수 내부로 코드의 제어권 이동
- 함수 코드 평가
1. ***함수 실행 컨텍스트 생성***
    - 실행 컨텍스트 스택에 push
2. ***함수 렉시컬 환경 생성***
    - foo 함수 실행 컨텍스트에 바인딩
    1. ***함수 환경 레코드 생성***
    2. ***this 바인딩***
        - 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 this가 바인딩됨
    3. ***외부 렉시컬 환경에 대한 참조 결정***
        - foo 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당
        - 전역 코드 평가 시점에 foo 함수의 정의가 평가되므로 전역 렉시컬 환경의 참조가 할당됨
        - 자바스크립트 엔진은 함수의 정의를 평가하여 함수 객체를 생성할 때 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 함수의 상위 스코프를 함수 객체의 내부 슬롯 `[[Environment]]`에 저장 → 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당되는 것은 바로 상위 스코프를 가리키는 함수 객체의 내부 슬롯 `[[Environment]]`에 저장된  렉시컬 환경의 참조

### 5. foo 함수 코드 실행
- foo 함수의 소스코드가 순차적으로 실행되며 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당됨
- bar 함수가 호출됨

### 6. bar 함수 코드 평가
![bar 함수 실행 컨텍스트와 렉시컬 환경](https://github.com/namu56/modern-javascript-study/assets/71831926/d26bebe5-36f7-47dd-9911-8d658c0dc03a)
- bar 함수 호출 시 foo 함수 코드의 실행을 일시 중지, bar 함수 내부로 코드의 제어권 이동
- 함수 코드 평가 (foo 함수 코드 평가와 동일)

### 7. bar 함수 코드 실행
- bar 함수의 소스코드가 순차적으로 실행되며 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 z에 값이 할당됨
- `console.log` 코드 실행
    1. `console` 식별자 검색
    2. `log` 메서드 검색
    3. 표현식 `a + b + x + y + z` 평가
    4. `console.log` 메서드 호출
- bar 함수가 호출됨

### 8. bar 함수 코드 실행 종료
- 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop되어 제거됨
- bar 함수 렉시컬 환경까지 즉시 소멸되지는 않음 (bar 함수 렉시컬 환경을 누군가 소멸하고 있다면 소멸하지 않음) → 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸

### 9. foo 함수 코드 실행 종료
- 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트가 pop되어 제거됨

### 10. 전역 코드 실행 종료
- 실행 컨텍스트 스택에서 전역 실행 컨텍스트가 pop되어 제거됨
- 스택이 모두 비워짐!

## 📌실행 컨텍스트와 블록 레벨 스코프
- `let`, `const` 키워드로 선언한 변수는 모든 코드 블록(함수,if 문, for 문, while 문, try/catch 문 등)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따름
- 코드 블록이 실행되면 코드 블록을 위한 블록 레벨 스코프를 생성해야 함
    - ⭐선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성해서 **기존의 전역 렉시컬 환경을 교체**
    - 새로 생성된 렉시컬 환경의 위부 렉시컬 환경에 대한 참조는 코드 블록이 실행되기 이전의 전역 렉시컬 환경을 가리킴
- 코드 블록의 실행이 종료되면 코드 블록이 실행되기 이전의 렉시컬 환경으로 되돌림
```jsx
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```
![image](https://github.com/namu56/modern-javascript-study/assets/71831926/2e4660f8-aefd-438c-9dbf-e09541da7324)
![image](https://github.com/namu56/modern-javascript-study/assets/71831926/02a21e39-94be-44e5-8ad4-78c9e44c6123)