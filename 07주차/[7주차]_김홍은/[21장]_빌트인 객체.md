### 📎 목차

1. [자바스크립트 객체의 분류](#1-자바스크립트-객체의-분류)
2. [표준 빌트인 객체](#2-표준-빌트인-객체)
3. [원시값과 래퍼 객체](#3-원시값과-래퍼-객체)
4. [전역 객체(global object)](#4-전역-객체global-object)

---

# 21장. 빌트인 객체

## 1) 자바스크립트 객체의 분류

- **표준 빌트인 객체(standard built-in objects/native objects/global objects)**

  - ECMAScript 사양에 정의된 객체
  - 애플리케이션 전역의 공통 기능을 제공
  - 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)과 관계없이 언제나 사용 가능
  - 전역 객체의 프로퍼티로서 제공되므로, 별도의 선언없이 전역 변수처럼 언제나 참조 가능

<br/>

- **호스트 객체(host objects)**

  - ECMAScript 사양에는 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체
  - 브라우저 환경에서는 클라이언트 사이드 Web API를 호스트 객체로 제공
    - Web API ⇒ DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등
  - Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공

- **사용자 정의 객체(user-defined objects)**
  - 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체

<br/><br/>

## 2) **표준 빌트인 객체**

- 자바스크립트는 `Object`, `String`, `Number`, `Boolean`, `Symbol`, `Date`, `Math`, `RegExp`, `Array`, `Map/Set`, `WeakMap/WeakSet`, `Function`, `Promise`, `Reflect`, `Proxy`, `JSON`, `Error` 등 40여 개의 표준 빌트인 객체를 제공한다.
- `Math`, `Reflect`, `JSON`을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.
  - 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적(static) 메서드를 제공
  - 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공
- 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 `prototype` 프로퍼티에 바인딩된 객체다.
  - ex) 표준 빌트인 객체 `String`을 생성자 함수로서 호출하여 생성한 `String` 인스턴스의 프로토 타입 ⇒ `String.prototype`
- 표준 빌트인 객체의 `prototype` 프로퍼티에 바인딩된 객체는 다양한 기능의 빌트인 프로토타입 메서드를 제공한다.
- 표준 빌트인 객체는 인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공한다.

```jsx
// Number 생성자 함수에 의한  Number 인스턴스 객체 생성
const numObj = new Number(1.5); // Number {1.5}

// toFixed는 Number.prototype의 프로토타입 메서드 ⇒ 소수점 자리를 반올림해서 문자열로 반환
console.log(numObj.toFixed()); // 2

// isInteger는 Number의 정적 메서드 ⇒ 인수가 정수인지 검사하여 결과를 Boolean으로 반환
console.log(Number.isInteger(0.5)); // false
```

<br/><br/>

## 3) 원시값과 래퍼 객체

- **문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라 한다.**
- ex) 문자열에 대해 마침표 표기법으로 접근할 경우

  ```jsx
  const str = "hi";

  // 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
  console.log(str.length); // 2
  console.log(str.toUpperCase()); // HI

  // 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
  console.log(typeof str); // string
  ```

  - 문자열에 대해 마침표 표기법으로 접근하는 순간, 래퍼 객체인 `String` 생성자 함수의 인스턴스가 생성되고 문자열은 래퍼 객체의 `[[StringData]]` 내부 슬롯에 할당됨
  - 이때 문자열 래퍼 객체인 `String` 생성자 함수의 인스턴스는 `String.prototype`의 메서드를 상속받아 사용 가능
  - 그 후 래퍼 객체의 처리가 종료되면 래퍼 객체의 `[[StringData]]` 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 됨

- 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용할 수 있으며, 표준 빌트인 객체인 `String`, `Number`, `Boolean`, `Symbol`의 프로토타입 메서드 또는 프로퍼티를 참조할 수 있다.
  - 따라서, `String`, `Number`, `Boolean` 생성자 함수를 사용하여 인스턴스를 생성할 때는 `new`연산자와 함께 호출할 필요가 없고 권장하지 않는다. (`Symbol`은 생성자 함수가 아니므로 이 논의에서 제외)
- 문자열, 숫자, 불리언, 심벌 이외의 원시값인 `null`, `undefined`는 래퍼 객체를 생성하지 않는다. ⇒ 객체처럼 사용하면 에러가 발생

<br/><br/>

## 4) 전역 객체(**global object**)

- 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체
- 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체(표준 빌트인 객체, 호스트 객체)의 최상위 객체
  - 전역 객체가 최상위 객체라는 것 ≠ 프로토타입 상속 관계상에서의 최상위 객체라는 의미
  - 전역 객체 자신은 어떤 객체의 프로퍼티도 아니며, 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 의미함
- 자바스크립트 환경에 따른 전역 객체
  - 브라우저 환경 : window (또는 self, this, frames)
  - Node.js 환경 : global

> **globalThis**
>
> - ECMAScript2020(ES11)에서 도입
> - 브라우저 환경과 Node.js 환경에서 전역 객체를 가리키던 다양한 식별자를 통일한 식별자
> - ECMAScript 표준 사양을 준수하는 모든 환경에서 사용 가능

<br/>

#### ◈ 전역 객체의 특징

- 전역 객체는 개발자가 의도적으로 생성할 수 없다. ⇒ 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않음
- 전역 객체의 프로퍼티를 참조할 때 `window`(또는 `global`)를 생략할 수 있다.
- **전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.**
- 자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.
  - 브라우저 환경 : 클라이언트 사이드 Web API(DOM, BOM, Canvas, fetch, Web Storage 등)를 호스트 객체로 제공함
  - Node.js 환경 : Node.js 고유의 API를 호스트 객체로 제공함
- **`var` 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.**
- **`let`이나 `const` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.**
  - `let`이나 `const` 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.
- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 `window`를 공유한다.
  - 여러 개의 `script`태그를 통해 자바스크립트 코드를 분리해도 하나의 전역 객체 `window`를 공유한다. ⇒ 분리되어 있는 자바스크립트 코드는 하나의 전역을 공유한다는 의미

<br/>

### (1) 빌트인 전역 프로퍼티(**built-in global property**)

- 전역 객체의 프로퍼티를 의미
- 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

**① `Infinity`**

- 무한대를 나타내는 숫자값 `Infinity`를 갖는다.

**② `NaN`**

- 숫자가 아님(Not-a-Number)을 나타내는 숫자값 `NaN`을 갖는다. (`NaN`은 `number`타입)
- `NaN` 프로퍼티는 `Number.NaN` 프로퍼티와 같다.

**③ `undefined`**

- 원시 타입 `undefined`를 값으로 갖는다.

<br/>

### (2) 빌트인 전역 함수(**built-in global function**)

- 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서, 전역 객체의 메서드다.

**① `eval`**

```jsx
// 주어진 문자열 코드를 런타임에 평가 또는 실행
eval(code);
```

- 자바스크립트 코드를 나타내는 문자열을 인수로 전달받는다.
  - 전달 받은 문자열 코드가 표현식인 경우 ⇒ 문자열 코드를 런타임에 평가하여 값을 생성함
  - 전달 받은 문자열 코드가 표현식이 아닌 문인 경우 ⇒ 문자열 코드를 런타임에 실행함
- 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행한 다음, 마지막 결과값을 반환한다.

```jsx
// 표현식인 문
eval("1 + 2;"); // 3

// 표현식이 아닌 문
eval("var x = 5;"); // undefined

// eval 함수에 의해 런타임에 변수 선언문이 실행되어 x 변수가 선언되었다.
console.log(x); // 5

// 문자열 코드가 여러개의 문으로 이루어진 경우, 마지막 결과값을 반환
eval("1 + 2; 3 + 4;"); // 7
```

- `eval` 함수는 기존의 스코프를 런타임에 동적으로 수정한다.
  - 단, strict mode에서의 `eval` 함수는 기존의 스코프를 수정하지 않고 `eval` 함수 자신의 자체적인 스코프를 생성함
- `eval` 함수를 통해 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 취약하며, 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 느리다. ⇒ **`eval` 함수의 사용은 금지해야 한다.**

**② `isFinite`**

```jsx
// 전달받은 인수가 유한수인지 확인하고 그 결과를 반환
isFinite(testValue);
```

- 전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 `true`, 무한수이면 `false` 반환
- 전달받은 인수의 타입이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사 수행
  - 인수가 `NaN`으로 평가되는 값인 경우 ⇒ `fasle` 반환
  - `null`은 숫자 타입으로 변환하면 0이므로 `isFinite(null)`은 `true`를 반환

**③ `isNaN`**

```jsx
// 주어진 숫자가 NaN인지 확인하고 그 결과 반환
isNaN(testValue);
```

- 전달받은 인수가 `NaN`인지 검사하여 그 결과를 불리언 타입으로 반환
- 전달받은 인수의 타입이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사 수행

**④ `parseFloat`**

- 전달받은 문자열 인수를 부동 소수점 숫자, 즉 실수로 해석하여 반환

```jsx
// 문자열 실수로 해석해 반환
parseFloat("3.14"); // → 3.14
parseFloat("10.00"); // → 10

// 공백으로 구분된 문자열은 첫 번째 문자열만 변환
parseFloat("34 45 66"); // → 34
parseFloat("40 years"); // → 40

// 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN 반환
parseFloat("He was 40"); // → NaN

// 앞뒤 공백은 무시됨
parseFloat(" 60 "); // → 60
```

**⑤ `parseInt`**

- 전달받은 문자열 인수를 정수로 해석하여 반환
- 첫 번째 인수로 전달한 문자열의 첫 번째 문자가 해당 지수의 숫자로 변환될 수 없다면 `NaN`을 반환한다.
- 두 번째 인수로 진법 나타내는 기수(2-36)를 전달할 수 있다.
  - 기수 지정 시 첫 번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석해 반환 ⇒ 반환값 언제나 10진수
  - 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶은 경우 ⇒ `Number.prototype.toString` 메서드를 사용
  - 기수 지정하지 않더라도 첫 번째 인수로 전달된 문자열이 `0x`, 또는 `0X`로 시작하는 16진수 리터럴이면 16진수로 해석하여 10진수 정수로 반환
  - 기수 지정하지 않을 경우, 2진수와 8진수 리터럴은 제대로 해석하지 못함 ⇒ 첫번째 인수로 전달된 문자열을 2진수 또는 8진수로 해석하기 위해서는 반드시 두 번째 인자로 기수를 지정해야함

```jsx
/* ex1) 문자열 정수로 해석해 반환 */
parseInt("10"); // → 10
parseInt("10.123"); // → 10

/* ex2) 전달받은 인수가 문자열이 아닌 경우, 문자열로 변환한 다음 정수로 해석해 반환 */
parseInt(10); // → 10
parseInt(10.123); // → 10

/* ex3) 기수 지정 시 첫 번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석해 반환 */
parseInt("10"); // → 10

// '10'을 2, 8, 16진수로 해석하고 그 결과를 10진수 정수로 반환
parseInt("10", 2); // → 2
parseInt("10", 8); // → 8
parseInt("10", 16); // → 16

/* ex4) 10진수 숫자를 해당 기수의 문자열로 변환하여 반환 */
const x = 15;

// 10진수 15를 2진수로 변환해 그 결과를 문자열로 반환
x.toString(2); // → '1111'
// 문자열 '1111'을 2진수로 해석하고 그 결과를 10진수 정수로 반환
parseInt(x.toString(2), 2); // → 15

// 10진수 15를 8진수로 변환해 그 결과를 문자열로 반환
x.toString(8); // → '17'
// 문자열 '17'를 8진수로 해석하고 그 결과를 10진수 정수로 반환
parseInt(x.toString(8), 8); // → 15

// 숫자값 문자열로 변환
x.toString(); // → '15'
// 문자열 '15'를 10진수로 해석하고 그 결과를 10진수 정수로 반환
parseInt(x.toStrig()); // → 15

/* ex5) 첫 번째 인수로 전달된 문자열이 0x, 또는 0X로 시작하는 16진수 리터럴인 경우 */
parseInt("0xf"); // → 15
parseInt("f", 16); // → 15

// 2진수 리터럴(0b로 시작)과 8진수 리터럴(0o로 시작)은 제대로 해석하지 못함
// 0 이후가 무시된다.
parseInt("0b10"); // → 0
parseInt("0o10"); // → 0

/* ex6) 문자열의 첫 번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환 */
// 'A'는 10진수로 해석 불가
parseInt("A0"); // → NaN

// '2'는 2진수로 해석 불가
parseInt("20", 2); // → NaN
```

**⑥ `encodeURI` / `decodeURI`**

![Untitled (3)](https://github.com/hongii/Book-Shop/assets/93701887/9f90cd3f-9d33-439f-a0ea-8ed021d8da3d)

- `encodeURI` 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.
  - URI : 인터넷에 있는 자원을 나타내는 유일한 주소
  - 인코딩 : URI의 문자들을 이스케이프 처리하는 것을 의미한다.
  - 이스케이프 처리 : 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
- URI 문법 형식 표준 RFC3986에 따르면 URL은 아스키 문자 셋으로만 구성되어야 하며 한글을 포함한 대부분의 외국어나 아스키 문자 셋에 정의되지 않은 특수 문자의 경우에는 URL에 포함될 수 없다.
  - 따라서, URL 내에서 의미를 갖고 있는 문자(&, ?, #)나 URL에 올 수 없는 문자(한글, 공백 등) 또는 시스템에 의해 해석될 수 있는 문자(<, >)는 이스케이프 처리가 필요하다.
  - 알파벳과 0~9의 숫자 그리고 - \_ . ! ~ \* ’ ( ) 문자는 이스케이프 처리에서 제외
- `decodeURI` 함수는 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩한다.

**⑦ `encodeURIComponent` / `decodeURIComponent`**

- `encdoeURIComponent` 함수는 URI 구성 요소를 인수로 전달받아 인코딩한다.
  - `encodeURIComponent` 함수는 문자열을 URI 구성 요소인 쿼리 스트링의 일부로 간주하기 때문에 쿼리 스트링 구분자로 사용되는 =, ?, &까지 인코딩한다.
  - 반면에, `encodeURI`는 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주하기 때문에 쿼리 스트링 구분자는 인코딩하지 않는다.
- `decodeURIComponent` 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다.

<br/>

### (3) 암묵적 전역

- 함수 내에서 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되므로, 마치 선언된 전역 변수처럼 동작한다. ⇒ 이러한 현상을 **암묵적 전역(implicit global)** 이라 한다.
- 변수 선언 없이 단지 전역 객체의 프로퍼티로 추가된 식별자는 변수가 아니므로, 변수 호이스팅이 발생하지 않는다.
- 전역 변수는 `delete` 연산자로 삭제할 수 없지만, 전역 객체의 프로퍼티는 `delete` 연산자로 삭제할 수 있다.
