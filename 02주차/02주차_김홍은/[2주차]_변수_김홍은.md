### 🔗 목차

1. [변수란?](#1-변수란)
2. [식별자](#2-식별자)
3. [변수 선언](#3-변수-선언)
4. [변수 선언의 실행 시점과 변수 호이스팅](#4-변수-선언의-실행-시점과-변수-호이스팅)
5. [값의 할당](#5-값의-할당)
6. [값의 재할당](#6-값의-재할당)
7. [식별자 네이밍 규칙](#7-식별자-네이밍-규칙)

---

# 4장. 변수

## 1) 변수란?

- **변수(Variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름**을 말한다.
- 쉽게 말해서, 변수란 값의 위치를 가리키는 상징적인 이름이다.
- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수명**(혹은 **변수 이름**)이라고 하며, 변수에 저장된 값을 **변수 값**이라고 한다.
- 변수에 값을 저장하는 것을 **할당(대입, 저장)** 이라고 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조**라고 한다.
- 변수명을 사용하여 참조를 요청하면, 자바스크립트 엔진은 변수명과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

<br/><br/>

## 2) 식별자

- **식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름**을 말한다.
- 변수, 함수, 클래스 등의 이름은 모두 식별자에 해당한다.
- 변수 값은 메모리 공간에 저장되어 있기 때문에, 식별자는 메모리 공간에 저장되어 있는 어떠한 값을 식별할 수 있어야 한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다.
  → 즉, **식별자는 값이 아니라 메모리 주소를 기억하고 있다.**
- 식별자가 값을 식별한다 라는 것은, 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장되어 있는 값에 접근할 수 있다는 의미다. 따라서, 식별자는 메모리 주소에 붙인 이름이라고 볼 수 있다.

<br/><br/>

## 3) 변수 선언

- 변수 선언이란, 간단히 말하자면 변수를 생성하는 것을 말한다.
- **값을 저장하기 위한 메모리 공간을 확보하고 변수명과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것을 의미**한다.
- 변수 뿐만 아니라 모든 식별자를 사용하기 위해서는 반드시 변수 선언이 선행되어야 한다.
- 선언하지 않은 식별자에 접근할 경우, `ReferenceError`(참조 에러)가 발생한다.
  - `ReferenceError`는 식별자를 통해 값을 참조하려 했지만, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 경우 발생하는 에러다.
- `var`, `let` , `const` 키워드를 사용하여 변수를 선언할 수 있다.

<br/>

### (1) 자바스크립트 엔진의 변수 선언 과정

1. **선언 단계** : **변수명을 등록**해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. **초기화 단계** : **값을 저장하기 위한 메모리 공간을 확보**하고 암묵적으로 **`undefined`를 할당하여 변수 값을 초기화** 한다.

여기서 초기화란, 변수가 선언된 이후 최초로 값을 할당하는 것을 의미한다.

```plain
cf) 변수명은 어디에 등록될까?
변수명을 비롯한 모든 식별자는 실행 컨텍스트에 `{ key: value }`의 형태의 객체로 등록된다.
(자바스크립트 엔진이 변수를 관리하는 매커니즘에 대한 자세한 내용은 13장 스코프와 23장 실행 컨텍스트를 참고)
```

<br/>

### (2) `var`변수의 선언 과정

```jsx
var score; // 선언 & 초기화가 동시에 일어남. 선언과 동시에 undefined로 초기화됨
```

- 선언 단계와 초기화 단계가 동시에 일어난다.
- 선언 단계를 통해 실행 컨텍스트에 변수명을 `score`이라고 등록하고, 초기화 단계를 통해 `score`변수에 암묵적으로 `undefined`를 할당해 초기화한다.

<br/><br/>

## 4) 변수 선언의 실행 시점과 변수 호이스팅

### (1) 변수 호이스팅이란?

- **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)** 이라고 한다.
- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자는 호이스팅 대상이 된다.
- 즉, 모든 선언문은 런타임 이전 단계에서 식별자의 선언이 먼저 실행된다.

<br/>

### (2) `var`변수의 호이스팅 예시

```jsx
console.log(score); // 출력 : undefined
var score; // var 변수 선언문
```

- 자바스크립트 코드는 **인터프리터**(인터프리터 개념은 2.5절 p14 참고)에 의해 한 줄씩 순차적으로 실행된다.
- 위의 코드 예시에서, `console.log(score);`가 가장 먼저 실행되고 순차적으로 그 다음 줄인 `var score;`가 된다. 그렇기에 아직 `score`변수를 선언이 일어나기 전에 `score`변수에 접근하였기 때문에 `ReferenceError`가 발생할 것이라 예상할 수 있다. 하지만, `ReferenceError`가 발생하지 않고 `undefined`가 출력된다.
  - 그 이유는, **변수 선언(선언 단계와 초기화 단계)이 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점) 이전 단계에서 먼저 실행되기 때문**이다.
  - 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정(23.2절 참고)을 거치면서 소스코드를 실행하기 위한 준비를 한다.
  - 소스코드의 평가 과정에서, 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 전부 찾아내 먼저 실행한다. → 호이스팅
  - 소스코드의 평가 과정이 끝나면 소스코드를 한 줄씩 순차적으로 실행한다.

<br/><br/>

## 5) 값의 할당

```jsx
/* ex1) 변수 선언과 값의 할당을 따로 하기 */
var score; // var 변수 선언
score = 80; // 값의 할당

/* ex2) 변수 선언과 값의 할당을 한번에 하기 */
var score = 100; // var 변수 선언 & 값의 할당
```

- **변수에 값을 할당할 때는 할당 연산자 `=`를 사용**한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.
- 위의 코드에서, ex1)과 ex2)의 코드는 정확히 동일하게 동작한다.
- 단, ex2)와 같이 변수선언과 값의 할당을 동시에 하더라도 변수 선언과 값의 할당의 실행 시점이 다르다는 것을 주의해야 한다.
- **변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**

  ```jsx
  console.log(score); // 출력 : undefined

  var score; // var 변수 선언 -> 런타임 이전에 실행
  score = 80; // 값의 할당 -> 런타임에 실행

  console.log(score); // 출력 : 80
  ```

- 변수에 값을 할당할 때는, 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 `80`을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하여 그 곳에 할당 값 `80`을 저장한다.

<br/><br/>

## 6) 값의 재할당

```jsx
var score = 80; // var 변수 선언 & 값의 할당
score = 90; // 값의 재할당

console.log(score); // 출력 : 90
```

- **재할당이란, 이미 값이 할당되어 있는 변수에 새로운 값을 또 다시 할당하는 것**을 말한다.
- `var`키워드로 선언한 변수는 값의 재할당이 가능하다.
  - `var` 키워드로 선언한 변수의 경우에는, 선언과 동시에 `undefined`로 초기화가 되기 때문에 변수에 처음으로 값을 할당하는 것도 사실상 재할당에 해당한다.
- `const`키워드로 선언한 변수는 재할당이 불가능하다. **`const`는 재할당이 불가능한 상수를 선언**한다.(const 키워드에 대해서는 15.3절 참고)
- 변수에 값을 재할당할 때는, 이전 값 `80`이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값 `90`을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하여 그 곳에 재할당 값 `90`을 저장한다.

<br/><br/>

## 7) 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용되지 않는다.
- 예약어는 식별자로 사용할 수 없다.
  </br>

- **사용 가능한 변수명 예시**

  ```jsx
  var person;
  var $elem;
  var _name;
  var first_name;
  var value1;
  ```

  </br>

- **사용 불가능한 변수명 예시**
  ```jsx
  var first-name; // SyntaxError: Unexpected token - : 하이픈은 변수명에 포함할 수 없음
  var 1st; // SyntaxError: Invalid or unexpected token : 변수명은 숫자로 시작할 수 없음
  var this; // SyntaxError: Unexpected token this : 예약어 this는 변수명으로 사용 불가능
  ```

<br/>

#### ◈ 자주 쓰이는 4가지 유형의 네이밍 컨벤션

```jsx
// 카멜 케이스(camelCase) : 첫 단어의 시작문자는 소문자로, 이후의 단어의 시작은 대문자로
var firstName;

// 스네이크 케이스(snake_case) : 모든 단어는 소문자로 쓰되, 언더스코어(_)로 단어를 연결함
var first_name;

// 파스칼 케이스(PascalCase) : 모든 단어의 시작 문자는 대문자로
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById("myId"); //  DOM 노드
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

- JS에서는 주로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수나 클래스의 이름에는 파스칼 케이스를 사용한다.
