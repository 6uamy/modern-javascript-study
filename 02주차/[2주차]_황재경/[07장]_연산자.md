# 📒07장_ 연산자
### 📑목차
- [산술 연산자(arithmetic operator)](#산술-연산자arithmetic-operator)
- [할당 연산자(assignment operator)](#할당-연산자assignment-operator)
- [비교 연산자(comparison operator)](#비교-연산자comparison-operator)
- [삼항 조건 연산자(ternary operator)](#삼항-조건-연산자ternary-operator)
- [논리 연산자(logical operator)](#논리-연산자logical-operator)
- [쉼표(`,`) 연산자](#쉼표-연산자)
- [그룹(`()`) 연산자](#그룹-연산자)
- [`typeof` 연산자](#typeof-연산자)
- [지수 연산자](#지수-연산자)
- [그 외의 연산자와 연산자의 부수 효과](#그-외의-연산자와-연산자의-부수-효과)
- [연산자 우선순위와 결합 순서](#연산자-우선순위와-결합-순서)

### ⚡Quick Summary
- 피연산자(operand)
    > 연산의 대상 (명사)
- 연산자(operator)
    > 값으로 평가된 피연산자를 연산하여 새로운 값을 만든다. (동사)
- 부수 효과(side effect)
    > 피연산자의 값을 변경
- 산술 연산자(arithmetic operator)는 산술 연산이 불가능하면 `NaN`반환
- 값이 `null` 타입인지 확인할 때는 `typeof` 대신 `===` 사용
- 연산자 우선순위는 높을수록 먼저 실행되는데 모두 기억하기는 어려우니 우선순위가 가장 높은 그룹(`()`) 연산자를 사용하여 우선순위를 명시적으로 조절

## 📌산술 연산자(arithmetic operator)
> 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값 생성

> 산술 연산이 불가능한 경우 `NaN` 반환
- 피연산자 개수에 따라 이항(피연산자 2개), 단항(피연산자 1개) 산술 연산자로 구분
    - 모든 이항 산술 연산자는 부수 효과X, 항상 새로운 값 생성
    - ⭐`+` 연산자는 **피연산자 중 하나 이상이 문자열**인 경우 *문자열 연결 연산자*로 동작
        ```jsx
        '1' + 2; // → '12'
        1 + '2'; // → '12'
        ```
    - 몫 연산자 없음 → `Math.floor(x / y)`로 계산
    - ⭐`+` 단항 산술 연산자의 경우 아무 효과가 없지만 **숫자 타입이 아닌 피연산자에 사용하여 숫자 타입으로 형변환**할 때 사용 가능 (`-` 단항 산술 연산자도 마찬가지)
        - `undefined` → `NaN`
        - `true` → `1`
        - `false`, `null` → `0`
    - **전위** 증가/감소 연산자(prefix increment/decrement operator)
        > **먼저 피연산자의 값을 증가/감소**시킨 후, 다른 연산 수행
    - **후위** 증가/감소 연산자(postfix increment/decrement operator)
        > 먼저 다른 연산을 수행한 후, **피연산자의 값을 증가/감소**시킴

|연산자|종류|의미|부수 효과|
|:--:|--|--|:--:|
|+|이항 산술 연산자|덧셈|X|
|-|이항 산술 연산자|뺄셈|X|
|*|이항 산술 연산자|곱셈|X|
|/|이항 산술 연산자|나눗셈|X|
|%|이항 산술 연산자|나머지|X|
|++|단항 산술 연산자|증가|O|
|--|단항 산술 연산자|감소|O|
|+|단항 산술 연산자|부호 그대로|X|
|-|단항 산술 연산자|부호 반전|X|

## 📌할당 연산자(assignment operator)
> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
- ⭐할당문 또한 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨
    ```jsx
    var a, b, c;
    // 연쇄 할당(오른쪽에서 왼쪽으로)
    a = b = c = 0;  // 모두 동일한 값(0)
    ```

|할당 연산자|의미|부수 효과|
|:--:|--|:--:|
|=|x = 5|O|
|+=|x += 5 ↔ x = x + 5|O|
|-=|x -= 5 ↔ x = x - 5|O|
|*=|x *= 5 ↔ x = x * 5|O|
|/=|x /= 5 ↔ x = x / 5|O|
|%=|x %= 5 ↔ x = x % 5|O|

## 📌비교 연산자(comparison operator)
> 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환
- 동등 비교(loose equality)
    > **암묵적 타입 변환을 통해 타입을 일치시키고** 값이 같은지 반환
- 일치 비교(strict equality)
    > 좌항과 우항의 피연산자의 **타입과 값**이 같은지 반환

|비교 연산자|의미|부수 효과|
|:--:|--|:--:|
|==|동등 비교|X|
|===|일치 비교|X|
|!=|부동등 비교|X|
|!==|불일치 비교|X|
|>|x > y|X|
|<|x < y|X|
|>=|x ≥ y|X|
|<=|x ≤ y|X|

- ⭐`NaN`은 자신과 일치하지 않는 유일한 값
    ```jsx
    NaN === NaN;    // false
    ```
    - ✔️숫자가 NaN인지 조사하려면 빌트인 함수 `Number.isNaN()`을 사용
        ```jsx
        Number.isNaN(NaN);              // true
        Number.isNaN(10);               // false
        Number.isNaN(1 + undefined);    // true
        ```
- `+0`과 `-0`도 비교하면 true를 반환😅
    ```jsx
    0 == -0;    // true
    0 === -0;   // true
    ```
    > ✔️ES6에서 도입된 `Object.is()` method를 사용하면 정확한 비교 결과를 반환<br>
    (다음 두 경우를 제외한 나머지는 `===`와 동일하게 동작)

    ```jsx
    -0 === +0;              // true
    Object.is(-0, +0);      // false

    NaN === NaN;            // false
    Object.is(NaN, NaN);    // true
    ```

## 📌삼항 조건 연산자(ternary operator)
> 조건식의 평가 결과에 따라 반환할 값 결정
- 자바스크립트의 유일한 삼항 연산자
- 부수 효과 없음
- 조건식 `?` 조건식이 true일 때 반환할 값 `:` 조건식이 false일 때 반환할 값
- ⭐`if … else` 문과 비슷하지만 `if … else` 문은 값으로 사용할 수 없는 **표현식이 아닌 문**이지만, **삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문**

## 📌논리 연산자(logical operator)
> 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산
- `!` 연산자는 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환 수행
- ⭐`||` 또는 `&&`의 평가 결과는 불리언 값이 아닐 수 있음 (단축 평가)
    - 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨

|논리 연산자|의미|부수 효과|
|:--:|--|:--:|
|\|\||논리합(OR)|X|
|&&|논리곱(AND)|X|
|!|부정(NOT)|X|

## 📌쉼표(`,`) 연산자
> ✔️왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 **마지막 피연산자의 평가 결과를 반환**
```jsx
var x, y, z;
x = 1, y = 2, z = 3;    // 3
```

## 📌그룹(`()`) 연산자
> 피연산자를 감싸며 자신의 피연산자인 표현식을 가장 먼저 평가
- 그룹 연산자로 우선순위 조절 가능
- 연산자 우선순위가 가장 높음

## 📌`typeof` 연산자
> 피연산자의 데이터 타입을 **문자열**로 반환
- 다음 7가지 문자열 중 하나를 반환 (데이터 타입과 정확히 일치하지는 않음🤨)
    - `"string"`
    - `"number"`
    - `"boolean"`
    - `"undefined"`
    - `"symbol"`
    - `"object"`
    - `"function"`
- `"null"`을 반환하는 경우는 없음!
- ⚠️주의 사항
    - `typeof`로 `null` 값을 연산하면 `"object"`를 반환 (자바스크립트 첫 번째 버전의 버그)
        > ⇒ ⭐값이 null 타입인지 확인할 때는 `typeof` 대신 `===` 사용
        ```jsx
        var foo = null;

        typeof foo === null;    // false
        foo === null;           // true
        ```
    - 선언하지 않은 식별자를 `typeof`로 연산하면 `ReferenceError`가 발생하지 않고 `undefined`를 반환함
        ```jsx
        typeof undeclared;  // undefined
        ```

## 📌지수 연산자
> 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭 제곱한 숫자 값 반환
- ES7에서 도입
- 도입되기 전에는 `Math.pow(base, exponent)` method를 사용했음
- 음수는 괄호로 묶어야 함
- 이항 연산자 중에서 우선순위가 가장 높음


## 📌그 외의 연산자와 연산자의 부수 효과
- 그 외의 연산자
    - `?.`: 옵셔널 체이닝 연산자(optional chaining operator)
    - `??`: null 병합 연산자
    - `delete`: 프로퍼티 삭제
    - `new`: 생성자 함수를 호출할 때 사용하여 인스턴스 생성
    - `instanceof`: 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
    - `in`: 프로퍼티 존재 확인
- 부수 효과가 있는 연산자
    - `=`
    - `++/--`
    - `delete`

## 📌연산자 우선순위와 결합 순서
- [연산자 우선순위](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence#%ED%91%9C): 연산자 실행 순서 (높을 수록 먼저 실행)
- 연산자 결합 순서: 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지 나타내는 순서