# 변수

## 변수란?

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름
즉, 값이 저장되어 있는 메모리 공간의 주소이다

## 변수가 필요한 이유

변수를 통해 안전하게 값에 접근할 수 있다.
만약, 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조한다면, 운영체제가 사용하고 있는 값을 변경하여 치명적인 오류가 발생할 수 도 있다

## 식별자

변수를 식별할 수 있는 고유한 이름
값이 아니라 값이 저장되어 있는 메모리 주소를 식별자와 연결한다

## 변수 선언

변수를 생성하는 것이다
변수 선언에는 총 2단계가 존재한다

1. var, let, const를 이용하여 변수 선언
2. 자바스크립트 엔진은 확보한 메모리 공간을 undefined로 초기화

## 변수 선언의 실행 시점과 호이스팅

변수 선언은 런타임이 아니라, 그 이전 단계에서 먼저 실행된다
즉, 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다

> 런타임이란?
> 소스코드가 순차적으로 실행되는 시점

호이스팅이란, 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 것을 말한다

## 할당

좌변의 변수에 값을 할당한다

```javascript
var score; // 변수 선언
score = 80; // 값의 할당
```

변수 선언과 달리, 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다

### 값의 할당 예제

호이스팅으로 인해, 변수는 코드의 선두에서 선언된 것 처럼 동작한다

```javascript
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

변수 선언과 값의 할당을 단축 표현해도 자바스크립트 엔진은 각각 2개의 문으로 나누어 실행한다

```javascript
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

변수에 값의 할당을 먼저 하더라도, 변수 선언이 선두에서 선언된 것처럼 동작하므로 정상적으로 값이 할당된다

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 80
```

## 재할당

var와 let을 이용하여 선언한 변수는 값을 재할당할 수 있다
const로 선언한 변수는 값을 변경할 수 없다

> 가비지 콜렉터
> 변수를 재할당하면, 이전의 값은더 이상 필요하지 않다. 이러한 붎필요한 값들을 쓰레기 값이라고 하며, 가비지 콜렉터에 의해 메모리에서 자동 해제된다.

## 식별자 네이밍 규칙

-   특수문자를 제외한 문자, 숫자, 언더 스코어(\_), 달러 기호($)를 사용할 수 있다
-   단, 식별자는 숫자로 시작하는 것은 허용하지 않는다
-   예약어는 식별자로 사용할 수 없다

```javascript
var person, $elem, _name, first_name, val1;

var 이름; // 유니코드 허용, 하지만 권장하지 않음

var first-name; // SyntaxError
var 1st; // SyntaxError
var this; // SyntaxError
```

자바스크립트는 대소문자를 구별한다.

```javascript
var firstname;
var firstName;
var FIRSTNAME;
```

### 네이밍 컨벤션

하나 이상의 영어 단어로 구성된 식별자를 만들 때, 가독성 좋게 보이도록 만들기 위해 규정한 규칙이다

```javascript
// 1. 카멜 케이스(camelCase)
var firstName;

// 2. 스네이크 케이스(snake_case)
var first_name;

// 3. 파스칼 케이스(PascalCase)
var arr = new Array();

// 4. 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
```

-   카멜 케이스는 보통 변수나 함수의 이름에 사용한다
-   파스칼 케이스는 생성자 함수, 클래스 이름에 사용한다

# 표현식과 문

## 값

표현식이 평가되어 생성된 결과

## 리터럴

문자 또는 약속된 기호를 사용해서 고정된 값을 생성하는 표기법
일종의 표현식

```javascript
// 숫자 리터럴 3
3;
```

## 표현식

값으로 평가될 수 있는 문(코드 조각)

1. 새로운 값 생성
2. 기존 값 참조

```javascript
// 리터럴 표현식
10;
('Hello');

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName;
```

## 문

프로그램의 최소 실행 단위
어떤 동작이나 작업을 수행하는 코드 조각

```javascript
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo() {}

// 조건문
if (x > 1) {
    console.log(x);
}

// 반복문
for (var i = 0; i, 2; i++) {
    console.log(i);
}
```

> 토큰(token)
> 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소
> ex. `var, sum, =, 1, +, 2, ;`

## 세미클론

문의 종료를 나타낸다
자바스크립트 엔진은 문의 끝을 예측하여 자동으로 세미클론을 붙여주는 기능이 암묵적으로 수행된다

## 6. 표현식인 문과 표현식이 아닌 문 구별 방법

문(코드 조각)을 변수에 할당해 본다

```javascript
// 표현식인 문은 값처럼 사용할 수 있다
var foo = x = 100;
console.log(foo); //100

// 표현식이 아닌 문은 값처럼 사용할 수 없다
var foo = var x; // SyntaxError: Unexpected token var
```

# 데이터 타입

값의 종류를 말한다.

원시 타입과 객체 타입으로 나눌 수 있다

## 원시 타입

### 숫자 타입

자바스크립트는 하나의 숫자 타입만 존재
모든 수를 실수로 처리

### 문자 타입

0개 이상의 16비트 유니코드 문자의 집합
텍스트 데이터를 내타내는데 사용

#### 문자열 표기 방법

1. 작은 따옴표('')
2. 큰 따옴표("")
3. 백틱(``)

#### 일반 문자열과 템플릿 리터럴의 차이

1. 멀티라인 문자열(줄바꿈 허용)
   일반 문자열 내에서는 줄바꿈이 허용되지 않지만, 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않아도 줄바꿈이 허용된다

1. 표현식 삽입
   일반 문자열 내에서는 문자열들을 + 연산자를 사용해 연결할 수 있지만, 템플릿 리터럴 내에서는 표현식 사입을 통해 간단히 문자열을 삽입할 수 있다

```javascript
var first = 'One-ik';
var last = 'Sin';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is One-ik Sin.

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`); // My name is One-ik Sin.
```

### 불리언 타입

논리적 참, 거짓을 나타내는 true, false
조건문에서 자주 사용한다

### undefined 타입

undefined가 유일
자바스크립트 엔진이 변수를 초기화 하기 위해 사용하는 값이다

```javascript
var foo;
console.log(foo); // undefined
```

### null 타입

null이 유일
대소문자를 구별하므로 Null, NULL 등과 다르다

```javascript
var foo = 'Sin';

// 이전 참조 제거
foo = null;
```

### undefined와 null의 차이

-   undefined는 개발자가 의도적으로 할당하기 위한 값이 아니다

-   null은 변수에 값이 없다는 것을 개발자가 의도적으로 명시할 때 사용한다

### 심벌 타입

다른 값과 중복되지 않는 유일무이한 값이다

```javascript
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); //symbol

// 객체 생성
var obj = {};

// 충돌 위험이 없은 심벌을 프로퍼티 키로 사용
obj[key] = 'value';
console.log(obj[key]); //value
```

### 객체 타입

원시 타입을 제외한 모든 값은 객체이다

## 데이터 타입의 필요성

### 메모리 공간의 확보

변수에 할당되는 값의 데이터 타입에 따라 확보해야할 메모리 공간의 크기가 결정된다

### 메모리 공간의 참조

자바스크립트 엔진은 변수에 값이 할당되어 있다면, 변수를 값의 데이터 타입으로 인식한다

예를 들어, 값의 데이터 타입이 숫자라면, 숫자 타입은 8바이트 단위로 저장되므로 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들인다

### 값의 해석

데이터 타입에 따라 2진수를 어떻게 해석하느냐 달라진다

## 자바스크립트의 특징

### 동적 타이핑

자바스크립트의 변수는 선언이 아닌 할당과 재할당에 의해 타입이 결정된다

즉, 변수는 타입을 갖지 않지만, 할당되는 값에 의해 타입이 동적으로 결정된다

### 동적 타입 언어의 장단점

-   장점
    유연성이 높다
-   단점
    1. 복잡한 프로그램에서 변화하는 변수 값을 추적하기 어려울 수 있다
    2. 값의 변경에 의해 타입도 언제든지 변경될 수 있다
    3. 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다

## 변수를 사용할 때 주의사항

1. 필요한 경우, 제한적으로 사용한다
2. 유효 범위(스코프)는 최대한 좁게 설정한다
3. 전역 변수는 최대한 사용하지 않는다
4. 변수보다는 상수를 사용한다
5. 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다

# 연산자

하나 이상의 표현식을 연산자를 사용하여 하나의 값으ㄹ 만든다

## 연산자의 종류

### 산술 연산자

### 이항 산술 연산자

2개의 피연산자를 산술 연산

```javascript
5 + 2; // -> 7
5 - 2; // -> 3
5 * 2; // -> 10
5 / 2; // -> 2.5
5 % 2; // -> 1
```

### 단항 산술 연산자

-   증감(++/--) 연산자
    피연산자의 값을 변경하는 부수 효과가 있다
    증감 연산자는 위치에 따라 의미가 다르다

```javascript
var x = 5,
    result;
// 선 할당 후 증가
result = x++;
console.log(result, x); // 5, 6

// 선 증가 후 할당
result = ++x;
console.log(result, x); // 7, 7
```

-   (+)단항 연산자
    숫자 타입이 아닌 피연산자에 사용하면, 숫자 타입으로 변환하여 반환한다
    피연산자를 변경하는 것은 아니기 때문에, 부수 효과는 없다

```javascript
var x = '1';

// 문자열을 숫자로 타입 변환
console.log(+x); // 1

// 부수 효과는 없다
console.log(x); // '1'

// 불리언 값을 숫자로 타입 변환
x = true;
console.log(+x); // 1

x = false;
console.log(+x); // 0

// 부수 효과는 없다
console.log(x); // true

// 문자열을 숫자로 변환할 수 없을 때는 NaN을 반환
x = 'Hello';
console.log(+x); // NaN

// 부수 효과는 없다
console.log(x); // 'Hello'
```

### 문자열 연결 연산자

-   +연산자는 문자열 연결 연산자로 동작한다

```javascript
// 문자열 연결 연산자
'1' + 2; // -> '12'

// true 1로 타입 변환 (암묵적 타입 변환)
1 + true; // -> 2
// false 1로 타입 변환 (암묵적 타입 변환)
1 + false; // -> 1
```

> 부수 효과란?
> 변수의 값에 영향을 미치는 것

### 할당

좌항의 변수에 값을 할당
값이 변하므로 부수 효과가 있다

### 비교

### 동등 비교 연산자

동등 연산자(==)는 좌항과 우항을 비교할 때, 암묵적으로 타입 변환을 통해 타입을 일치시킨 후 비교한다

```javascript
5 == 5; // -> true

5 == '5'; // -> true
```

그러나, 위와 같이 편리한 경우도 있지만, 결과를 예측하기 어렵다는 단점이 있다

```javascript
'0' == ''; // -> false
0 == ''; // -> true
0 == '0'; // -> true
false == 'false'; // -> false
false == '0'; // true
false == null; // false
false == undefined; // false
```

### 일치 비교 연산자

좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우 true를 반환한다

```javascript
5 === 5; // -> true

5 === '5'; // -> false
```

### 사용시 주의할 점

1. NaN
   일치 연산자를 사용할때, NaN을 주의하자
   NaN은 자기 자신과 일치하지 않는 유일한 값이다.

    ```javascript
    NaN === NaN; // -> false
    ```

    Number.isNaN을 사용하여 숫자가 NaN인지 조사할 수 있다.

    ```javascript
    Number.isNaN(NaN); // -> true
    Number.isNaN(10); // -> false
    ```

2. 숫자 0
   양의 0과 음의 0을 비교하면 true 반환

    ```javascript
    0 === -0; // -> true

    0 == -0; // -> true
    ```

### 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값 반환

### 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정
삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다

```javascript
var x = 2;

// 2 % 2 = 0. 0은 false로 암묵적 타입 변환
// x % x가 true이면, '홀수' 반환 false 이면, '짝수' 반환
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수
```

### 5. 논리 연산자

우항과 좌항의 피연산자를 논리 연산

```javascript
// 논리합(OR) 연산자
// 하나만 일치해도 true
true || true; // -> true
true || false; // -> true
false || true; // -> true
false || false; // -> false

// 논리곱(AND) 연산자
// 둘 다 일치해야 true
true && true; // -> true
true && false; // -> false
false && true; // -> false
false && false; // -> true

// 논리 부정(!) 연산자
!true; // -> false
!false; // -> false
```

### 그룹 연산자

소괄호('()')로 피연산자를 감싸 우선순위를 조절한다

```javascript
10 * 2 + 3; // -> 23

// 그룹 연산자를 사용하여 우선순위 조절
10 * (2 + 3); // -> 50
```

### typeof 연산자

데이터 타입을 문자열로 반환

```javascript
typeof ''; // -> "string"
typeof 1; // -> "number"
typeof NaN; // -> "number"
typeof true; // -> "boolean"
typeof undefined; // -> "undefined"
typeof Symbol(); // -> "symbol"
typeof null; // -> "object"
typeof function () {}; // -> "function"
```

null은 object를 반환하기 때문에, 주의하자

### 그 외 연산자

|   연산자   |                          개요                          |
| :--------: | :----------------------------------------------------: |
|     ?.     |                  옵셔널 체이닝 연산자                  |
|     ??     |                    null 병합 연산자                    |
|   delete   |                     프로퍼티 삭제                      |
|    new     |                     인스턴스 생성                      |
| instanceof | 좌변의 객체가 우변의 인스턴스로 만들어진 객체인지 판별 |
|     in     |                   프로퍼티 존재 확인                   |

## 연산자의 부수 효과

할당 연산자(=), 증감 연산자(++/--), delete 연산자는 다른 코드에 영향을 주므로, 부수 효과가 있다

```javascript
var x;

// 할당 연산자
x = 1;
console.log(x) // 1

// 증감 연산자
x++;
console.log(x); // 2

// delete 연산자
var o = { a: 1 };
delete.o.a;
console.log(o) // {}
```

## 연산자의 우선순위

모두 기억하기 어려우므로 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장한다
