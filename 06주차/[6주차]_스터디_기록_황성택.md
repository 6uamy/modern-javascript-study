## 질문 사항

### 성택 > 원익

- Q) 프로토타입 체인에 대해 간략하게 설명해주세요
  - A) 상속과 프로퍼티 탐색을 위한 매커니즘, 특정 프로퍼티/메서드 해당 객체에 존재하지 않을경우 내부슬롯이 참조하고 있는
  부모객체를 검색하며 찾아가게 되고 최상위 객체까지 검색하는 과정을 거치게 됩니다. (찾는 프로퍼티가 없으면 undefined를 반환하게 됩니다.)

### 원익 > 재경

- Q) 프로토타입의 생성 시점에 대해 설명해주세요.
  - A) 사용자 정의 생성자 함수는 함수 객체가 생성이 될때 같이 정의되게 되고, 빌트인 객체의 경우에도 동일하게 함수가 생성되는 시점에 프로토타입이 생성됩니다.<br>
  모든 빌트인 함수는 전역 객체가 생성되는 시점에 생성됩니다.

### 재경 > 홍은

- Q) 프로퍼티 섀도잉에 대해 설명해주세요.
  - A) 어떤 생성자 함수와 연결되어 있는 프로토타입의 프로퍼티/메서드가 있을때, 동일한 프로퍼티/메서드를 인스턴스에서 생성할 경우<br>
  상위 프로퍼티/메서드를 교체하는 것이 아니라 인스턴스에서 새로 재정의(오버라이딩) 되게 되는데, 이를 통해 상위 객체의 프로퍼티/메서드가 가려지게 되는 현상을 말합니다.

- Q) 오버라이딩과 오버로딩에 대해 설명해주세요.
  - A) 오버라이딩: 동일한 이름을 가진 메서드를, 하위 인스턴스에서 재정의 하는 것을 말합니다.<br>
  오버로딩: 동일한 메서드 이름을 가지지만, 전달받는 매개변수의 개수나 타입을 다르게 정의하여 사용하는 것을 말하고,<br>
  js에서는 오버로딩이라는 개념이 존재하지 않지만 arguments 객체를 통해 비슷하게 구현해볼 수 있습니다. 

### 홍은 > 성택

- Q) 프로퍼티의 존재를 확인하는 방법에 대해 설명해주세요.
  - A) 첫번째로 in 연산자를 사용하는 방법이 있습니다. in 연산자의 경우에는 프로토타입 체인 상에 존재하는 모든 프로토타입에서 프로퍼티 여부를 검색하고,<br>
  두번째 방법으로는 Object.prototype.hasOwnProperty 메서드를 사용하는 방법이 있고 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 여부에 대해 검색을 진행합니다.
    
### 재경 > ALL
- Q) 프로퍼티를 열겨하는 방법에는 어떤 것이 있는지 설명해주세요.
  - 홍은) for ... in문을 사용하는 방법: 해당 객체의 프로토타입 체인에 존재하는 모든 프로퍼티를 열거하게 되는데,<br>
  그 중 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 검색하고, 객체 고유만의 열거 가능한 프로퍼티 키를 받기 위해선<br>
  Object.keys/values/entries 메서드를 사용하게 됩니다.
    
### 재경 > ALL
- Q) 프로토타입의 내부 슬롯 값이 null인 경우
  - 성택) Object.prototype의 경우 최상단 프로토타입 체인에 존재하기에 프로토타입의 내부 슬롯의 값으로 null을 가지게 되는 것 같습니다.
  재경님 추가 답변) Object.create의 인자 값으로 null을 지정하는 경우에도 내부 슬롯 값으로 null을 가지는 것 같습니다.
  토론) Object.create(null)의 경우 Object.prototype을 상위 객체로 가지지 않고 독립적인 객체 형태로 생성되게 됩니다. (Object.prototype 빌트인 메서드 사용이 불가능)
  
### 재경 > ALL
- Q) 객체리터럴과 오브젝트 생성자 함수의 차이점?
  - 성택) 프로퍼티를 생성하는 방식의 차이가 있는 것 같습니다. 객체 리터럴의 경우에는 객체 내부에 프로퍼티를 생성하고,<br>
  오브젝트 생성자 함수의 경우에는 일단 빈 객체를 생성한 후 프로퍼티를 추가하는 방식으로 알고 있습니다.

### 원익 > ALL
- Q) 정적 프로퍼티/메서드에 대해 설명해주세요.
  - 재경) 생성자 함수 자체도 객체이기에 자신만의 프로퍼티/메서드를 가질 수 있는데 이를 정적 프로퍼티/메서드라 합니다. <br>
  또한 생성자 함수를 통해 생성한 인스턴스 객체는 정적 프로퍼티/메서드에 접근할 수 없다는 특징이 있습니다.
