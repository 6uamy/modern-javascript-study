### 🔗 목차

1. [객체란?](#1-객체란)
2. [객체 리터럴에 의한 객체 생성](#2-객체-리터럴에-의한-객체-생성)
3. [프로퍼티](#3-프로퍼티)
4. [메서드](#4-메서드)
5. [프로퍼티 접근](#5-프로퍼티-접근)
6. [프로퍼티 값 갱신](#6-프로퍼티-값-갱신)
7. [프로퍼티 동적 생성](#7-프로퍼티-동적-생성)
8. [프로퍼티 삭제](#8-프로퍼티-삭제)
9. [ES6에서 추가된 객체 리터럴의 확장 기능](#9-es6에서-추가된-객체-리터럴의-확장-기능)

---

# 10장. 객체 리터럴

## 1) 객체란?

- 자바스크립트는 객체(object) 기반의 프로그래밍 언어이며, 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
- 0개 이상의 프로퍼티로 구성된 집합으로, 프로퍼티는 **키(key)** 와 **값(value)** 으로 구성된다.
- 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.
  - 자바스크립트의 함수는 일급 객체(18절 참고)이므로 값으로 취급되기 때문에 함수 또한 프로퍼티 값으로 사용할 수 있다.
  - **프로퍼티 값이 함수인 경우에는** 일반 함수와 구분하기 위해 **메서드(method)라고 부른다.**
- 이처럼, 객체는 프로퍼티와 메서드로 구성된 집합체이다.
  - 프로퍼티 : 객체의 상태를 나타내는 값(data)
  - 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

![Untitled (2)](https://github.com/hongii/Book-Shop/assets/93701887/654f7063-9576-4f95-a287-7093bf760161) ![Untitled (3)](https://github.com/hongii/Book-Shop/assets/93701887/ffd5599b-1a1b-4e12-8a66-58782c96f709)
<br/>

#### ◈ 원시 타입과 객체 타입의 비교 (자세한 내용은 11절 참고)

| 원시 타입의 값                    | 객체 타입(object/reference type)의 값                                             |
| --------------------------------- | --------------------------------------------------------------------------------- |
| 단 하나의 값만 나타냄             | 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조 |
| 변경 불가능한 값(immutable value) | 변경 가능한 값(mutable value)                                                     |

<br/><br/>

## 2) 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타입 기반 객체지향 언어로서, 다양한 객체 생성 방법을 지원한다.
  - 객체 리터럴
  - `Object` 생성자 함수
  - 생성자 함수
  - `Object.create` 메서드
  - 클래스(ES6)
- 참고로, C++이나 자바는 클래스 기반 객체 지향 언어로서, 클래스를 사전에 정의하고 필요한 시점에 `new` 연산자와 함께 생성자(constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.
  <br/>

#### ◈ 객체 리터럴을 사용한 객체 생성 방법

- 객체를 생성하기 위한 표기법
- 중괄호(`{...}`) 내에 0개 이상의 프로퍼티를 정의
- 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성
- 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식
  - 클래스 기반 객체 지향 언어와는 달리, 클래스를 먼저 정의하고 `new` 연산자와 함께 생성자를 호출할 필요가 없음
  - 객체 리터럴에 프로퍼티를 포함시켜서 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고 객체를 생성한 이후에 동적으로 프로퍼티를 추가할 수도 있음

```jsx
/* 객체 리터럴로 객체 생성 */
var person = {
  name: "Lee",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};

console.log(typeof person); // object
console.log(person); // {name: 'Lee', sayHello: ƒ}

/* ex1) 중괄호 내에 프로퍼티를 정의하지 않은 경우에는 빈 객체가 생성된다 */
var empty = {}; // 빈 객체 생성
console.log(typeof empty); // object
```

<br/><br/>

## 3) 프로퍼티

- **객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**

```jsx
var person = {
  // 프로퍼티 키는 name, 프로퍼티 값은 'Lee'
  name: "Lee",
  // 프로퍼티 키는 age, 프로퍼티 값은 20
  age: 20,
};
```

- 프로퍼티를 나열할 때 쉽표(`,`)로 구분한다. - 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심볼 값 - 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값
  <br/>

#### ◈ 프로퍼티 키

- 프로퍼티 값에 접근할 수 있는 이름으로서 식별자 역할을 한다.
- 식별자 네이밍 규칙을 준수하는 이름 → 따옴표 생략 가능
- 식별자 네이밍 규칙을 준수하지 않는 이름 → 반드시 따옴표 사용 (따옴표를 생략할 경우 Error 발생)

```jsx
/* ex1) 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키를 따옴표를 감싼 경우 */
var person = {
  firstName: 'Ung-mo', // 식별자 네이밍 규칙을 준수하는 프로퍼티 키
  'last-name': 'Lee', // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
};

console.log(person); // {firstName: 'Ung-mo', last-name: 'Lee'}

/* ex2) 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키를 따옴표를 감싸지 않은 경우 */
var person2 = {
  firstName: 'Ung-mo',
  last-name: 'Lee', // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
};

console.log(person2); // SyntaxError: Unexpected token '-'
```

<br/>

#### ◈ 프로퍼티 키를 동적 생성하는 방법

- 문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다.
- 프로퍼티 키로 사용할 표현식을 대괄호(`[...]`)로 묶어서 사용한다.

```jsx
var obj = {};
var key = "hello";

// ES5: 프로퍼티 키 동적 생성
obj[key] = "world";

// ES6: 계산된 프로퍼티 이름
// var obj = { [key]: 'world' };

console.log(obj); // {hello: 'world'}
```

<br/>

#### ◈ 다양한 형태의 프로퍼티 키

- **빈 문자열의 프로퍼티 키**

  - 빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지는 않지만, 키로서의 의미를 갖지는 못하므로 권장되지 않는다.

  ```jsx
  var foo = {
    "": "",
  };

  console.log(foo); // {"": ''}
  ```

- **문자열이나 심벌 값 이외의 값을 사용한 프로퍼티 키**

  - 암묵적 타입 변환을 통해 문자열로 변환된다.

  ```jsx
  var foo = {
    0: 1,
    1: 2,
    2: 3,
  };

  // 따옴표는 붙지 않지만 내부적으로는 문자열로 변환
  console.log(foo); // {0: 1, 1: 2, 2: 3}
  ```

- **예약어를 사용한 프로퍼티 키**

  - 예약어를 프로퍼티 키로 사용해도 에러가 발생하지는 않지만, 예상치 못한 에러가 발생할 여지가 있으므로 권장하지 않는다.

  ```jsx
  var foo = {
    var: "",
    function: "",
  };

  console.log(foo); // {var: '', function: ''}
  ```

- **프로퍼티 키 중복 선언**

  - 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.
  - 이때 에러가 발생하지 않으므로 주의해야 한다.

  ```jsx
  var foo = {
    name: "Lee",
    name: "Kim",
  };

  console.log(foo); // {name: 'Kim'}
  ```

<br/><br/>

## 4) 메서드

- 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다.
- 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.
  - 즉, **메서드는** **객체에 묶여 있는 함수를 의미**한다.

```jsx
var circle = {
  radius: 5, // 프로퍼티
  getDiameter: function () {
    // 원의 지름를 구하는 메서드
    return 2 * this.radius; // this는 circle을 가리킴 (this에 대해서는 22장 참고)
  },
};

console.log(circle.getDiameter()); // 10
```

<br/><br/>

## 5) 프로퍼티 접근

- **프로퍼티에 접근하는 방법**
  - **마침표 표기법(dot notaion)** : 마침표 프로퍼티 접근 연산자(`.`)를 사용
  - **대괄호 표기법(bracket notation)** : 대괄호 프로퍼티 접근 연산자(`[]`)를 사용
    - 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 **반드시** **따옴표로 감싼 문자열**이어야 한다.
    - 대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 이를 식별자로 해석하기 때문이다.
    - 단, 프로퍼티 키가 숫자로 이루어진 문자열인 경우에는 따옴표를 생략할 수 있다.
- 프로퍼티 키가 식별자 네이밍 규칙을 준수한 경우 위의 두 표기법 모두 사용 가능하다.
- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 경우, 반드시 대괄호 표기법을 사용해야 한다.
- 마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자의 좌측에는 객체로 평가되는 표현식 기술한다.
- 마침표 프로퍼티 접근 연산자 우측 또는 대괄호 프로퍼티 접근 연산자 내부에는 프로퍼티 키를 지정한다.
- **객체에 존재하지 않는 프로퍼티에 접근하면 `undefined` 반환한다.** 이때는 `ReferenceError`가 발생하지 않는다.

```jsx
var person = {
  name: 'yuna',
	'last-name': 'Lee',
	1: 10
};

// 마침표 표기법
console.log(person.name); // yuna

// 대괄호 표기법: 프로퍼티 키를 따옴표로 감싸서 사용
console.log(person['name']); // yuna

// 대괄호 표기법: 프로퍼티 키를 따옴표로 감싸지 않은 경우, name을 식별자로 해석한다.
// 하지만, name이라는 식별자가 선언되어 있지 않으므로 ReferenceError 발생
console.log(person[name]); // ReferenceError: name is not defined

// 객체에 존재하지 않는 프로퍼티에 접근한 경우 -> undefined를 반환
console.log(person.age); // undefined

// 프로퍼티 키가 숫자인 경우 -> 대괄호 표기법을 사용하되, 따옴표는 생략 가능
consol.log(person.1); // SyntaxError
consol.log(person.'1'); // SyntaxError
consol.log(person[1]); // 10
consol.log(person['1']); // 10
```

<br/><br/>

## 6) 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

```jsx
var person = {
  name: "Lee",
};

// person 객체에 name이라는 프로퍼티가 존재하므로, name 프로퍼티의 값이 갱신된다.
person.name = "Kim";

console.log(person); // {name: 'Kim'}
```

<br/><br/>

## 7) 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

```jsx
var person = {
  name: "Lee",
};

// person 객체에는 age 프로퍼티가 존재하지 않는다.
// 따라서, person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당된다.
person.age = 20;

console.log(person); // {name: 'Lee', age: 20}
```

<br/><br/>

## 8) 프로퍼티 삭제

- `delete` 연산자로 객체의 프로퍼티를 삭제할 수 있다.
  - `delete`연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.
- 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.

```jsx
var person = {
  name: "Lee",
};

// 프로퍼티 동적 생성
person.age = 20;
console.log(person); // {name: 'Lee', age: 20}

// 프로퍼티 삭제
delete person.age;
console.log(person); // {name: 'Lee'}

// 존재하지 않는 프로퍼티 삭제 -> 에러는 발생하지 않음.(그냥 무시됨)
delete person.address;
console.log(person); // {name: 'Lee'}
```

<br/><br/>

## 9) ES6에서 추가된 객체 리터럴의 확장 기능

### (1) 프로퍼티 축약 표현

- 객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다.
- 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.
- ES6에서는 **프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략 가능하다. 이떄 프로퍼티 키는 변수 이름으로 자동 생성된다.**

```jsx
// ES5
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}

// ES6
let x = 1,
  y = 2;

const obj = { x, y }; // 프로퍼티 축약 표현

console.log(obj); // {x: 1, y: 2}
```

<br/>

### (2) **계산된 프로퍼티 이름**

- 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다.
  - 단, 프로퍼티 키로 사용할 표현식을 대괄호(`[...]`)로 묶어야 한다.
  - 이를 **계산된 프로퍼티 이름**이라고 한다.
- **ES5**에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성하는 방법
  - 객체 리터럴 **외부**에서 **대괄호 표기법** 사용
- **ES6**에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성하는 방법
  - 객체 리터럴 **내부**에서도 **대괄호 표기법** 사용하여 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성 가능

```jsx
var prefix = "prop";
var i = 0;

var obj = {};

// ES5 -> 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}

// ES6
const prefix = "prop";
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

<br/>

### (3) 메서드 축약 표현

- ES5에서는 메서드를 정의하려면 프로퍼티 값으로 함수를 할당해야 한다.
- ES6에서 메서드를 정의할 때는 `function` 키워드를 생략한 축약 표현을 사용할 수 있다.
  - 단, 메서드 축약 표현으로 정의한메서드는 프로퍼티에 할당한 함수와는 다르게 동작한다.(26장 참고)

```jsx
// ES5
var person = {
  name: "Lee",
  sayHi: function () {
    console.log("Hi! " + this.name);
  },
};

person.sayHi(); // Hi! Lee

// ES6
const person = {
  name: "Lee",
  sayHi() {
    // 메서드 축약 표현(function 키워드를 생략)
    console.log("Hi! " + this.name);
  },
};

person.sayHi(); // Hi! Lee
```
