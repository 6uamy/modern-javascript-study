# `let`, `const` 키워드와 블록 레벨 스코프

## 1) `var` 키워드로 선언한 변수의 문제점

### 1-1) 변수 중복 선언 허용

-   초기화문이 있다면, `var` 키워드가 없는 것처럼 동작
-   초기화문이 없다면, 변수 선언문은 무시된다

    ```js
    var x = 1;
    var y = 1;

    var x = 100; // var 키워드 무시 즉, 100만 재할당
    var y; // 선언문 무시

    console.log(x); // 100
    console.log(y); // 1
    ```

### 1-2) 함수 레벨 스코프

-   함수의 코드 블록만 지역 스코프로 인정한다
-   함수 외부에서 `var` 키워드로 선언된 변수는 모두 전역 변수이다

### 1-3) 변수 호이스팅

-   스코프의 선두로 끌어올려진 것 처럼 동작한다
-   `var` 키워드로 선언한 변수는 **선언 단계**와 **초기화 단계**가 한번에 진행된다
-   즉, 변수 선언문 이전에 참조할 수 있고, 할당문 이전에 참조하면 `undefined`를 반환받는다

## 2) `let` 키워드

-   `var` 키워드의 단점을 보완하기 위해 ES6에서 도입하였다

### 2-1) 중복 선언 불가

-   `var` 키워드와는 달리, 중복 선언한면 문법 에러(SyntaxError)가 발생한다

### 2-2) 블록 레벨 스코프

-   모든 코드 블록을 지역 스코프로 인정한다

### 2-3) 변수 호이스팅

-   호이스팅이 발생하지 않는 것처럼 동작한다
-   `let` 키워드로 선언한 변수는 **선언 단계**와 **초기화 단계**가 분리되어 진행된다
-   `TDZ`(일시적 사각지대)가 발생한다

    -   스코프의 시작 ~ 초기화(선언) 시작 지점까지 변수를 참조할 수 없는 구간이다

    ```js
    console.log(foo); // ReferenceError: foo is not defined

    let foo; // 변수 선언(초기화)
    console.log(foo); // undefined

    foo = 1; // 할당 단계
    console.log(foo); // 1
    ```

-   호이스팅이 발생하지 않는 것처럼 보이지만, 여전히 호이스팅이 발생한다

    ```js
    let foo = 1; // 전역 변수

    {
        console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
        let foo = 2;
    }
    ```

### 2-4) 젼역객체와 let

-   `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다

    ```js
    let x = 1;

    console.log(window.x); // undefined
    console.log(x); // 1
    ```

-   `var`키워드로 선언한 변수, 전역 함수, 암묵적 전역은 전역 객체(`window`)의 프로퍼티다

    -   암묵적 전역이란, 선언하지 않은 변수에 값을 할당하는 것을 말한다

    ```js
    var x = 1; // 전역 변수
    y = 2; // 암묵적 전역
    function foo() {} // 전역 함수

    console.log(window.x); // 1, 전역 변수는 전역 객체의 프로퍼티
    console.log(window.y); // 2, 암묵적 전역은 전역 객체의 프로퍼티
    console.log(window.foo); // f foo() {}, 전역 함수는 전역 객체의 프로퍼티
    ```

## 3) const 선언

### 3-1) 선언과 초기화

-   `const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다
-   그렇지 않으면, 문법 에러(`SyntaxError`)가 발생한다

### 3-2) 재할당 금지

-   `const` 키워드로 선언한 변수는 재할당이 금지된다

```js
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable
```

### 3-3) 상수

-   재할당이 금지된 변수이다
-   원시 값(`immutable value`)을 할당한다면, 변수 값을 변경할 수 없다
-   객체를 할당한다면, 객체의 값을 변경할 수 있다
    -   식별자는 객체의 주소값을 참조할 뿐이고, 객체는 변경 가능한 값이기에 변경할 수 있다

## 4) 변수 선언 키워드 사용 권장 사항

-   `var` 키워드는 왠만하면 사용하지 않는다
-   `let` 키워드는 재할당이 필요한 경우만 사용한다
-   `const` 키워드는 변경이 발생하지 않고, 읽기 전용에 사용한다
