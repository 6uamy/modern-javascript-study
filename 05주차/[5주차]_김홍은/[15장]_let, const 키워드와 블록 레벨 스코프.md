### 📎 목차

1. [`var` 키워드로 선언한 변수의 문제점](#1-var-키워드로-선언한-변수의-문제점)
2. [`let` 키워드](#2-let-키워드)
3. [`const` 키워드](#3-const-키워드)
4. [`var` vs `let` vs `const`](#4-var-vs-let-vs-const)

---

# 15장. let, const키워드와 블록 레벨 스코프

## 1) `var` 키워드로 선언한 변수의 문제점

### (1) 변수 중복 선언 허용

- `var` 키워드로 선언한 변수는 중복 선언이 가능하다.
- 만약 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 중복 선언하고 값까지 할당한 경우에는 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생한다.

<br/>

### (2) 함수 레벨 스코프

- `var` 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정한다.
- 함수 외부에서 `var` 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
- 함수 레벨 스코프는 전역 변수 사용을 남발할 가능성을 높이기 때문에 의도치 않게 전역 변수가 중복 선언되는 문제를 발생시킬 수 있다.

<br/>

### (3) `var` 키워드 변수 호이스팅

- `var` 키워드로 선언한 변수는 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작하기 때문에, 변수 선언문 이전에 참조가 가능하다.(할당문 이전에 변수를 참조할 경우 `undefined`를 반환)
- 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지 않지만 프로그램의 흐름에 맞지 않으며 가독성을 떨어뜨리고 오류를 발생시킬 수 있다.

<br/><br/>

## 2) `let` 키워드

- `var` 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 `let`과 `const`를 도입

<br/>

### (1) 변수 중복 선언 금지

- `let` 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러(`SyntaxError`)가 발생한다.

<br/>

### (2) 블록 레벨 스코프

- `let` 키워드로 선언한 변수는 모든 코드 블록(함수, `if`문, `for`문, `while`문, `try/catch`문 등)을 지역 스코프로 인정하는 블록 레벨 스코프(block-level scope)를 따른다.

```jsx
let foo = 1; // 전역 변수

{
  let foo = 2; // 지역 변수
  let bar = 2; // 지역 변수
}

console.log(foo); // 1
console.log(bar); // ReferenceError: bar is not defined ⇒ 전역에서는 지역 변수 참조 불가능
```

- 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다.
  ![Untitled (8)](https://github.com/hongii/Book-Shop/assets/93701887/868bc793-659e-4bde-b8ba-55912c236b82)

<br/>

### (3) `let` 키워드 변수 호이스팅

- `let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

  - 하지만 실제로는 `let` 키워드로 선언한 변수도 변수 호이스팅이 발생한다.
  - 호이스팅 대상 : 모든 선언(`var`, `let`, `const`, `function`, `function*`, `class` 등)

  ```jsx
  let foo = 1; // 전역 변수

  {
    // 런타임 이전에 foo 변수 호이스팅
    console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
    let foo = 2; // 지역 변수
  }
  ```

- `var` 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계와 초기화 단계가 한 번에 진행된다.
  - `var` 키워드로 선언한 변수는 변수 선언문 이전에 참조하는 경우 ⇒ `undefined`를 반환
- `let` 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
  - `let` 키워드로 선언한 변수는 변수 선언문 이전에 참조하는 경우 ⇒ **참조 에러(ReferenceError) 발생**
- `let` 키워드로 선언한 변수는 스코프 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다.
- 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(Temporal Dead Zone, TDZ)** 라고 부른다.

```jsx
// 런타임 이전에 선언 단계가 실행됨. 아직 변수 초기화가 되지 않은 상태
// 초기화 이전의 일시적 사각 지대에서는 변수를 참조할 수 없음
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계 실행
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행
console.log(foo); // 1
```

![Untitled](https://github.com/hongii/Book-Shop/assets/93701887/d5919afb-2c39-4c3e-b1c8-8cdeb545409d) ![Untitled (1)](https://github.com/hongii/Book-Shop/assets/93701887/e40119d7-335a-4a67-9558-4b88f6d100d5)

<br/>

### (4) 전역 객체와 `let`

- `var` 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 `window`의 프로퍼티가 된다.
  - 전역 객체의 프로퍼티를 참조할 때 `window`를 생략할 수 있다.
- `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
  - `let` 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재한다.

```jsx
// 이 예제는 브라우저 환경에서 실행해야 한다.

/* var 키워드 전역 변수 */
var x = 1;

/* 암묵적 변수 */
y = 2;

/* 전역 함수 */
function foo() {}

// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다.
consol.log(window.x); // 1

// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다.
consol.log(x); // 1

// 암묵적 전역은 전역 객체 window의 프로퍼티다.
consol.log(window.y); // 2
consol.log(y); // 2

// 함수선언문으로 정의한 전역 함수는 전역 객체 window의 프로퍼티다.
consol.log(window.foo); // f foo() {}

// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다.
consol.log(foo); // f foo() {}

/* let 키워드 전역 변수 */
let z = 1;

// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.
console.log(window.z); // undefined
console.log(z); // 1
```

<br/><br/>

## 3) `const` 키워드

- `const` 키워드는 상수(constant)를 선언하기 위해 사용한다.
  - 하지만 반드시 상수를 위해서만 사용하는 것은 아니다.
- `const` 키워드의 특징은 `let` 키워드와 대부분 동일하다.

<br/>

### (1) 선언과 초기화

- `const` 키워드로 선언한 변수는 반드시 **선언과 동시에 초기화**해야 한다. ⇒ 그렇지 않으면 문법 에러(`SyntaxError`) 발생
  ```jsx
  const foo; // SyntaxError: Missing initializer in const declaration
  ```
- `const` 키워드로 선언한 변수도 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
  ```jsx
  {
    // 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
    // 하지만 실제로는 const 키워드 변수도 변수 호이스팅이 발생함
    console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
    const foo = 1;
    console.log(foo); // 1
  }
  // 블록 레벨 스코프를 갖는다.
  console.log(foo); // ReferenceError: foo is not defined
  ```

<br/>

### (2) 재할당 금지

- `var` 또는 `let` 키워드로 선언한 변수는 재할당이 자유로우나 **`const` 키워드로 선언한 변수는 재할당이 금지된다.**

```jsx
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable.
```

<br/>

### (3) 상수

- **상수 ⇒ 재할당이 금지된 변수**
- **`const` 키워드로 선언된 변수**에 **원시 값을 할당**한 경우
  - 원시 값 ⇒ 변경할 수 없는 값
  - `const` 키워드 변수 ⇒ 재할당이 금지된 변수
  - 따라서, `const` 키워드 변수에 할당된 값을 변경할 수 있는 방법은 없다.
- 상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다.
  - 여러단어를 표현할 때는, 언더 스코어(`_`)로 구분하여 스네이크 케이스로 표현하는 것이 일반적이다.
  - ex) `const TAX_RATE = 0.1;`

<br/>

### (4) `const` 키워드와 객체

- **`const` 키워드로 선언된 변수에 객체를 할당한 경우에는 값을 변경(교체)할 수 있다.** ⇒ 객체는 변경 가능한 값(참조 값)이므로 재할당 없이 직접 변경이 가능하기 때문
- `const` 키워드는 재할당을 금지할 뿐 "불변"을 의미하지 않는다.
- 즉, `const` 키워드 변수에 새로운 값을 재할당 하는 것은 불가능 하지만, 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체의 속성을 수정하는 것은 가능하다.

```jsx
const person = {
  name: "Lee",
};

// 객체는 변경 가능한 값이므로, 재할당 없이 변경이 가능함
person.name = "Kim";
console.log(person); // {name:"Kim"}
```

<br/><br/>

## 4) `var` vs `let` vs `const`

- ES6를 사용한다면 `var` 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 `let`키워드를 사용한다.
  - 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 `const`키워드를 사용한다.
  - `const`키워드는 재할당을 금지하므로 `var`, `let` 키워드 보다 안전하다.

|                                  | **`var`**                                          | **`let`**        | **`const`**                        |
| -------------------------------- | -------------------------------------------------- | ---------------- | ---------------------------------- |
| **호이스팅**                     | 선언 단계와 초기화 단계(`undefined`)가 동시에 진행 | 선언 단계만 진행 | 선언 단계만 진행                   |
| **변수 선언 이전에 접근할 경우** | `undefined`를 반환                                 | `ReferenceError` | `ReferenceError`                   |
| **스코프**                       | 함수 레벨 스코프                                   | 블록 레벨 스코프 | 블록 레벨 스코프                   |
| **변수 값의 재할당**             | 재할당 가능                                        | 재할당 가능      | 재할당 불가능                      |
| **중복 선언 허용 여부**          | 중복 선언 허용                                     | 중복 선언 불가   | 중복 선언 불가                     |
| **비고**                         |                                                    |                  | 반드시 선언과 동시에 초기화 해야함 |
