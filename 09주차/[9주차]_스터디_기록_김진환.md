## 질문 사항

### 진환 > 성택

- Q) ES6에서 배열의 메서드와 스프레드 문법을 적절히 혼합하여 사용하는 것이 권장되는 이유는 무엇인가요?
  -A) 스프레드 문법과 슬라이싱 메서드를 사용하면 원본 배열을 유지하면서 새로운 배열을 반환하기 때문입니다.

### 성택 > 원익

- Q) ES6 메서드의 super 참조 동작에 대해 설명해 주세요.
  - A) ES6메서드는 자신을 바인딩한 객체를 가리키는 `[[HomeObject]]` 내부슬롯을 갖기 때문에 `super` 키워드를 통한 참조가 가능합니다.

### 원익 > 홍은

- Q) 화살표 함수와 일반 함수의 차이는 무엇인가요?

  - A) 화살표 함수와 일반 함수의 가장 큰 차이점은 `this` 바인딩입니다.
    화살표 함수는 함수 자체의 `this` 바인딩을 갖지 않기 때문에 `this`는 전역을 가리키게 되고, 일반 함수는 함수가 정의된 위치의 스코프를 가리키게 됩니다.

    또 다른 특징으로 화살표 함수는 non-constructor 함수이기 때문에 호출 시 프로토타입을 생성하지 않습니다.

### 홍은 > 재경

- Q) 메서드 내부의 콜백함수로 일반 함수를 전달하게 되면 어떤 문제가 발생할 수 있을까요?
  - A) 메서드의 `this`와 일반함수의 `this` 바인딩이 달라 서로 다른 값을 가리키기 때문에 `this` 키워드 사용 시 문제가 발생할 수 있습니다.
- Q) 그럼 이 문제를 어떻게 해결할 수 있을까요?
  - A) 1. 콜백 함수 외부(상위 함수 블럭)에 `this`를 변수에 담아 회피시킨 뒤 콜백 함수 내부에서 사용한다. 2. 콜백 함수로 화살표 함수를 사용해 `this`가 전역을 가리키게 한다. 3. `Function.prototype.bind` 메서드를 사용해 `prefix` 객체를 가리키는 `this`를 바인딩한다.

### 재경 > 진환

- Q) JS의 배열에서 요소를 삭제하는 방법에는 무엇이 있을까요?
  -A) `delete` 키워드와 배열 메서드(`pop`, `shift`, `splice` 등), 스프레드 문법 등을 통해 수행할 수 있습니다.
  이 떄 `delete` 키워드를 사용하는 경우 배열이 희소배열이 되는 문제가 발생할 수 있으므로, 가급적 메서드나 스프레드 문법을 사용하는 것이 권장됩니다.

추가 질문

- Q) JS 배열이 일반 배열 자료구조와 다르게 삽입, 삭제 등의 동작이 빠르게 작동하는 이유는 무엇일까요?
  -A) List 개념처럼 다음 요소와의 연결관계만 변경하면 되기 때문입니다.

- Q) JS 배열이 실제 배열이 아니지만 일반 배열처럼 검색속도가 빠른 이유는 무엇일까요?
  -A) JS 배열은 객체 구조이기 때문에, Key : Value 매칭과 Hash Map의 구조의 장점을 가지기 때문입니다.

- Q) 그래도 일반 배열보다 검색 속도가 실제로는 느린데, 이 이유는 무엇일까요?
  -A) JS의 배열은 다양한 타입을 하나의 배열에 저장할 수 있기 때문에 타입 검사와 같은 부가적인 로직을 포함하기 때문입니다.
