# 📒26장_ ES6 함수의 추가 기능
### 📑목차
- [함수의 구분](#함수의-구분)
- [메서드(method)](#메서드method)
- [화살표 함수(arrow function)](#화살표-함수arrow-function)
- [Rest 파라미터](#rest-파라미터)
- [매개변수 기본값](#매개변수-기본값)

### ⚡Quick Summary
- ES6 이전 함수 객체
    - callable & constructor
    - 일반 함수, 생성자 함수, 메서드 등 동일한 함수라도 다양한 형태로 호출 가능
    - *메서드*
        > 객체에 바인딩된 함수
- ES6 함수 객체
    - *일반함수*
        - callable & constructor
        - ES6 이전 함수 객체와 동일
    - *메서드*
        > **메서드 축약 표현**으로 정의된 함수
        - callable & non-constructor
        - 메서드 축약 표현으로 정의된 함수만이 내부 슬롯 `[[HomeObject]]`를 가짐
        - super 참조는 내부 슬롯 `[[HomeObject]]`를 사용해서 수퍼클래스의 메서드를 참조하므로 메서드 축약 표현으로 정의된 함수에서만 사용 가능
    - *화살표 함수*
        - callable & non-constructor
        - 함수 자체의 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않음
        - 화살표 함수 내에서 `this`, `arguments`, `super`, `new.target` 바인딩을 참조하면 ***식별자처럼 스코프 체인을 통해 상위 스코프에 바인딩된 값***을 참조

        
## 📌함수의 구분
- ES6 이전까지 자바스크립트의 함수는 별다른 구분 없이 다양한 목적으로 사용됨
    ```jsx
    var foo = function () {
        return 1;
    };

    // 일반적인 함수로서 호출
    foo(); // -> 1

    // 생성자 함수로서 호출
    new foo(); // -> foo {}

    // 메서드로서 호출
    var obj = { foo: foo };
    obj.foo(); // -> 1
    ```
- ES6 이전의 모든 함수(일반적으로 메서드라고 부르던 객체에 바인딩된 함수도)는 일반 함수 및 생성자 함수로서 호출 가능 (즉, callable이면서 constructor)
- 이는 언뜻 보면 편리한 것 같지만 실수를 유발시킬 수 있으며 메서드나 콜백 함수의 경우 불필요한 프로토타입 객체를 생성하기 때문에 성능 면에서 손해
- 🤗그래서 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분!

    | ES6 함수의 구분 | constructor | prototype | super | arguments |
    | --- | :---: | :---: | :---: | :---: |
    | 일반 함수(Normal) | ⭕ | ⭕ | ❌ | ⭕ |
    | 메서드(Method) | ❌ | ❌ | ⭕ | ⭕ |
    | 화살표 함수(Arrow) | ❌ | ❌ | ❌ | ❌ |
    - 일반 함수는 ES6 이전의 함수와 차이가 없음
    - 메서드와 화살표 함수는 non-constructor

    | 설명 | 호칭 |
    | --- | --- |
    | 내부 메서드 `[[Call]]`을 갖는 호출 가능한 함수 객체 (일반 객체는 호출 불가능) | callable |
    | 내부 메서드 `[[Construct]]`을 갖는 인스턴스를 생성할 수 있는 함수 객체 | constructor |
    | 내부 메서드 `[[Construct]]`을 갖는 인스턴스를 생성할 수 있는 함수 객체 | non-constructor |
  
    ![image](https://github.com/namu56/modern-javascript-study/assets/71831926/4cf83258-6606-4608-bd92-9a0bad36cb10)

## 📌메서드(method)
- ES6 이전 사양에서는 메서드에 대한 명확한 정의가 없었고 일반적으로 메서드는 객체에 바인딩된 함수를 일컫는 의미로 사용됨
- ⭐ES6 사양에서 메서드는 ***메서드 축약 표현**으로 정의된 함수*만을 의미
```js
const obj = {
  x: 1,
  // foo는 메서드
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1

// 메서드는 non-constructor이기 때문에 생성자 함수로서 호출 불가능
new obj.foo(); // -> TypeError: obj.foo is not a constructor
new obj.bar(); // -> bar {}

// prototype 프로퍼티 없음 (프로토타입도 생성 X)
obj.foo.hasOwnProperty('prototype'); // -> false

// 일반 함수는 prototype 프로퍼티 존재
obj.bar.hasOwnProperty('prototype'); // -> true
```
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 가짐
- super 참조는 내부 슬롯 `[[HomeObject]]`를 사용해서 수퍼클래스의 메서드를 참조
- ES6 메서드가 아닌 함수는 내부 슬롯 `[[HomeObject]]`를 가지지 않기 때문에 super 키워드 사용 불가능!
- ✔️프로퍼티 값으로 익명 함수 표현식 할당하는 ES6 이전의 방식은 사용하지 말고 메서드를 정의할 때에는 무조건 ***메서드 축약 표현***으로!!!

## 📌화살표 함수(arrow function)
- `function` 키워드 대신 화살표(`=>`, fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수 정의 가능
### 정의 방법
- 함수 표현식으로 정의 (함수 선언문으로 정의 불가능)
- 매개변수가 여러 개인 경우 소괄호 `()` 안에 매개변수 선언
- 매개변수가 한 개인 경우 소괄호 생략 가능
- 매개변수가 없는 경우 소괄호 생략 불가능
- 함수 몸체가 하나의 문으로 구성되는 경우 함수 몸체를 감싸는 중괄호 `{}` 생략 가능
    - 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문인 경우 암묵적으로 반환됨
    - 중괄호를 생략한 경우 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생
- 객체 리터럴의 중괄호를 함수 몸체를 감싸는 중괄호로 잘못 해석하기 때문에 객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 `()`로 감싸야 함
- 함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 `{}` 생략 불가능
- 화살표 함수도 즉시 실행 함수(IFE, Immediately-invoked Function Expression)로 사용 가능
- 화살표 함수도 일급 객체

### 화살표 함수와 일반 함수 차이
- 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor
    - prototype 프로퍼티 X
    - 프로토타입 생성 X
- 화살표 함수는 중복된 매개변수 이름 선언 불가능
    - 놀랍게도 일반 함수는 중복된 매개변수 이름을 선언해도 에러 발생 X<br>(strict mode에서는 에러 발생)
- ⭐화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않음
    - 따라서 화살표 함수 내부에서 `this`, `arguments`, `super`, `new.target`을 참조하면 ***스코프 체인을 통해 상위 스코프의 것***을 참조!
    - 화살표 함수와 화살표 함수가 중첩되어 있는 경우 상위 화살표 함수에도 `this`, `arguments`, `super`, `new.target` 바인딩이 없으므로 ***⭐스코프 체인 상에서 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 것***을 참조: *lexical this*

### this
- `this` 바인딩은 **함수가 어떻게 호출되었는지**에 따라 `this`에 바인딩할 객체가 **동적으로** 결정됨
- 일반 함수로 호출하면 `this`는 전역 객체를 가리킴 👉 [22장 > 일반 함수 호출](../../07주차/[7주차]_황재경/[22장]_this.md#일반-함수-호출) 참고
- 클래스 내부의 모든 코드에서는 암묵적으로 strict mode가 적용됨 👉 [25장](../../08주차/[8주차]_황재경/[25장]_클래스.md) 참고
    - strict mode에서 일반 함수로서 호출된 모든 함수 내부의 `this`에는 `undefined`가 바인딩됨 ⇒ "콜백 함수 내부의 `this` 문제" 발생
- "콜백 함수 내부의 `this` 문제"를 해결하기 위한 방법
    - ES6 이전
        - 메서드를 호출한 `this` 객체를 회피시킨 후 콜백 함수 내부에서 사용
        - `Function.prototype.bind` 메서드를 사용해서 메서드를 호출한 `this`를 바인딩
    - ES6
        - *화살표 함수*로 해결 가능
            - 화살표 함수는 *실행 컨텍스트 생성 시*, `this`를 바인딩을 갖지 않음 (`[[thisValue]]` 슬롯 존재 X)
            - 함수 자체의 `this` 바인딩을 갖지 않기 때문에 화살표 함수 내부에서 `this`를 참조하면 일반적인 식별자처럼 스코프 체인을 통해 상위 스코프의 `this`를 그대로 참조!
- 메서드에 할당한 화살표 함수 내부의 `this`는 전역의 `this`가 가리키는 전역 객체를 가리키므로 메서드에 화살표 함수를 할당하는 것은 바람직하지 않음 (그냥 ES6 메서드 축약 표현으로 정의한 ES6 메서드 사용)

### super
- 화살표 함수 자체의 super 바인딩을 갖지 않음
- 화살표 함수 내부에서 super를 참조하면 `this`와 마찬가지로 상위 스코프의 super를 참조

### arguments
- 화살표 함수 자체의 arguments 바인딩을 갖지 않음
- 화살표 함수 내부에서 arguments를 참조하면 `this`와 마찬가지로 상위 스코프의 arguments를 참조 → 화살표 함수 자신에게 전달된 인수 목록을 확인할 수 없기 때문에 도움이 안됨

## 📌Rest 파라미터
> Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점 `...`을 붙여서 정의한 매개변수로 **함수에 전달된 인수들의 목록을 배열로 전달받음**
- 일반 매개 변수와 함께 사용 가능 (순차적으로 할당됨)
- ✔️Rest 파라미터는 반드시 마지막 파라미터여야 함
- Rest 파라미터는 단 하나만 선언 가능
- ⭐Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않음 👉 [18장 > 함수 객체의 length 데이터 프로퍼티](../../05주차/[5주차]_황재경/[18장]_함수와%20일급%20객체.md#함수-객체의-프로퍼티) 참고
    ```js
    function foo(...rest) {}
    console.log(foo.length); // 0

    function bar(x, ...rest) {}
    console.log(bar.length); // 1

    function baz(x, y, ...rest) {}
    console.log(baz.length); // 2
    ```

## 📌매개변수 기본값
- ES6에서 도입됨
- 매개변수에 인수를 전달하지 않거나 `undefined`를 전달한 경우에 매개변수 기본값이 사용됨
- Rest 파라미터에는 기본값 지정 불가능
- 매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않음
