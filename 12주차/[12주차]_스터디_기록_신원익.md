## 질문 사항

### 원익 > 성택

-   Q) 전통적인 비동기 처리를 위한 콜백 패턴의 단점은 무엇이 있나요?
    -   A) 첫 번째로는 콜백 헬이라는 문제가 발생하게 되는데, 계속된 콜백 함수가 중첩되서 복잡도가 증가하고 가독성도 나빠지는 현상이 발생한다는 단점이 있고, 두 번째로는 에러 처리에 한계가 있습니다. 타이머 함수의 콜백 함수에서 에러가 발생하면 에러 처리를 catch 문에서 잡을 수 없는 문제점이 발생하게 됩니다.
-   Q) 이와 같은 문제를 해결하기 위해서 ES6에서 프로미스가 도입되게 되었는데, 프로미스란 무엇인가요?
    -   A) 프로미스는 비동기 처리를 위한 패턴입니다. 프로미스는 pending, fulfilled, rejected와 같은 비동기 처리에 관한 상태 정보를 가지고 있고, 상태 정보에 따라 결과값을 반환하는 객체입니다.

### 성택 > 진환

-   Q) 에러 처리가 필요한 이유는 무엇일까요?

    -   A) 애플리케이션 자체의 안정성이 향상되고, 유지보수 과정에서 디버깅 하는 데도 우리가 직관적으로 볼 수 있고, 리소스를 해지하는 측면에서도 도움이 된다라고 생각합니다.
    -   성택님 추가 답변
        -   에러는 언제든 발생할 수 있고, 이런 예외적인 상황을 대응하지 않게 되는 예상치 못한 프로그램이 종료될 가능성이 있기 때문에 에러 처리의 필요성은 필수적이다라고 할 수 잇을 것 같습니다.

-   Q) 에러 처리에서 에러가 발생하게 되면 에러의 전파는 어떻게 이루어지나요?
    -   A) 콜 스택을 따라서 상위 컨텍스트로 넘어가게 되는데, 즉 콜 스택의 아래 방향으로 전파됩니다.
-   Q) 그러면 에러가 전파되는 중간에 그 에러를 캐치하지 않게 되면 어떠한 현상이 발생하나요?
    -   A) 에러를 캐치하지 않아 리소스 누수가 발생합니다.
    -   성택님 추가 답변
        -   콜 스택의 위에서부터 마지막 전역 실행 컨텍스트까지 에러가 전파되게 되는데, 이러한 에러 전파를 중간에서 캐치하지 않으면 결국 프로그램이 강제 종료되는 현상이 발생합니다.

### 진환 > 홍은

-   Q) finally라는 키워드로 블록을 만들게 되는데, 이 finally 키워드가 무엇인지 설명해 주실 수 있나요?

    -   A) finally는 try ... catch ... finally 라고 해서 try 에서 실행된 코드에서 에러가 발생할 경우 캐치해서 catch 블록에서 실행이 되는데, finally는 에러가 발생했든 하지 않았든 마지막에 한 번 수행되는 블록입니다.

-   A) 맞습니다. 그런데, 저는 굳이 finally가 왜 필요할까라는 생각이 들었는데, 프로그래밍 할 때 어떻게 사용할 수 있는지 예시 같은 것을 말씀해주시겠어요?

    -   A) 직접 finally를 써본 적은 많이 없지만, 백엔드 프로젝트할 때 사용해봤는데, 성공했든 실패했든 상관없이 정리해야 될 때 작업을 해야 되는 코드 블록이라고 생각을 했습니다. 예를 들어 커넥션 풀 같은 경우 마지막에 커넥션을 해제해주기 위해 release같은 함수를 finally 블록에 작성하였습니다.
    -   진환님 추가 답변
        -   finally는 공통적인 작업을 하나로 캡슐 해주는 역할로도 사용할 수 있지만, finally가 등장하게 된 배경이나 가장 많이 사용되는 부분을 보면 리소스의 불필요한 연결 유지 같은 부분이 큽니다. 그래서 로컬에서 사용하는 경우에는 파일 자체를 오픈한 다음 어떤 작업을 수행하든 에러가 발생하든 나중에 파일을 한 번 클로즈 해주는 과정이 필요하고, 말씀해 주신 것처럼 작업이 성공하는 에러가 발생하든 데이터베이스와의 연결을 끊어주기 위해 많이 사용하는 것 같습니다.

### 홍은 > 원익

-   Q) 최신 자바스크립트에서 비동기 처리의 대표적인 방법 두 가지는 어떤 것들이 있을까요?
    -   A) Promise와 async/await 이 있습니다.
-   Q) 그러면 Promise와 async/await을 사용할 때 에러 처리하는 방법에 대해 각각 설명해주시겠어요?
    -   A) Promise 같은 경우는 catch 메서드를 사용해서 reject시 실행할 콜백 함수를 인자로 받고, rejected 상태가 되면 이 콜백 함수를 실행합니다. async/await 같은 경우는 try ... catch 블록을 통해 에러 처리를 하게 되는데, try 블록에 실행할 코드를 작성하고, 에러가 발생하면 catch 블록에서 실행하게 됩니다.
    -   홍은님의 추가 답변
        -   조금 더 정리를 해보자면 프로미스를 사용할 때 에러 처리 방법에는 then 메서드에서도 두 번째 인자로 실패 처리 콜백 함수를 전달받아 에러 처리를 할 수 있지만, 이 방법은 권장되지 않고 catch 메서드를 통해 에러 처리하는 방법이 권장된다고 합니다. 그리고 async/await에서는 말씀하신것처럼 try ... catch 문을 사용해서 에러 처리를 할 수 있지만, 만약 try ... catch 문을 사용하지 않는다면 async 함수에서 발생한 에러는 reject하는 프로미스를 반환하기 때문에, 이후에 프로미스 후속 메서드인 catch 메서드를 사용해서 에러 처리를 할 수도 있다고 합니다.
